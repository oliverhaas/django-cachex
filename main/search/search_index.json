{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"django-cachex","text":"<p>Full featured Valkey and Redis cache backend for Django with a built-in admin interface.</p> <p> </p>"},{"location":"#why-django-cachex","title":"Why django-cachex?","text":"<p>Drop-in replacement for Django's built-in Redis cache backend with extended features:</p> <ul> <li>Built-in admin interface - Browse, search, edit, and delete cache keys from Django admin</li> <li>Unified Valkey and Redis support - Single package for both backends</li> <li>Extended data structures - Hashes, lists, sets, sorted sets</li> <li>Sync and async support - All extended methods available in both sync and async</li> <li>TTL and pattern operations - <code>ttl()</code>, <code>expire()</code>, <code>keys()</code>, <code>delete_pattern()</code></li> <li>Lua script support - Register and execute Lua scripts with automatic key prefixing</li> <li>Distributed locking - <code>cache.lock()</code> for cross-process synchronization</li> <li>Sentinel and Cluster - High availability and horizontal scaling</li> <li>Pluggable serializers - Pickle, JSON, MsgPack with fallback support</li> <li>Pluggable compressors - Zlib, Gzip, LZ4, LZMA, Zstandard with fallback support</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.12+</li> <li>Django 5.2+</li> <li>valkey-py 6.1+ or redis-py 6.0+</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Install with pip:</p> <pre><code>pip install django-cachex[valkey]\n</code></pre> <p>Configure as cache backend:</p> <pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",  # or RedisCache\n        \"LOCATION\": \"valkey://127.0.0.1:6379/1\",       # or redis://...\n    }\n}\n</code></pre> <p>Enable the admin interface (optional):</p> <pre><code>INSTALLED_APPS = [\n    # ...\n    \"django_cachex.admin\",  # or \"django_cachex.unfold\" for django-unfold users\n]\n</code></pre>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>This project was inspired by django-redis and Django's official Redis cache backend. Some utility code for serializers and compressors is derived from django-redis, licensed under BSD-3-Clause. The admin functionality was inspired by django-redisboard.</p> <p>The Unfold theme integration optionally uses django-unfold.</p> <p>See also django-valkey and dj-cache-panel for related projects with similar goals.</p>"},{"location":"#license","title":"License","text":"<p>MIT License. See LICENSE for details.</p>"},{"location":"migration/","title":"Migration Guide","text":""},{"location":"migration/#from-djangos-built-in-cache-backend","title":"From Django's Built-in Cache Backend","text":"<pre><code># Before (Django's Redis backend)\n\"BACKEND\": \"django.core.cache.backends.redis.RedisCache\"\n\n# After (Valkey)\n\"BACKEND\": \"django_cachex.cache.ValkeyCache\"\n\n# Or (Redis)\n\"BACKEND\": \"django_cachex.cache.RedisCache\"\n</code></pre> <p>All existing Django cache options work unchanged.</p>"},{"location":"migration/#from-django-valkey","title":"From django-valkey","text":"<pre><code># Before\n\"BACKEND\": \"django_valkey.cache.ValkeyCache\"\n\"OPTIONS\": {\"CLIENT_CLASS\": \"django_valkey.client.DefaultClient\"}\n\n# After\n\"BACKEND\": \"django_cachex.cache.ValkeyCache\"\n</code></pre> <p>Key changes:</p> django-valkey django-cachex <code>CLIENT_CLASS</code> Removed - use specific backend class <code>SERIALIZER</code> <code>serializer</code> (lowercase) <code>COMPRESSOR</code> <code>compressor</code> (lowercase) <code>CONNECTION_POOL_CLASS</code> <code>pool_class</code> <code>get_valkey_connection()</code> <code>cache.get_client()</code> <p>Import paths: <code>django_valkey.*</code> \u2192 <code>django_cachex.*</code></p> <p>For Sentinel: Use <code>django_cachex.cache.RedisSentinelCache</code> (or <code>ValkeySentinelCache</code>) instead of <code>CLIENT_CLASS</code>.</p>"},{"location":"migration/#from-django-redis","title":"From django-redis","text":"<pre><code># Before\n\"BACKEND\": \"django_redis.cache.RedisCache\"\n\"OPTIONS\": {\"CLIENT_CLASS\": \"django_redis.client.DefaultClient\"}\n\n# After\n\"BACKEND\": \"django_cachex.cache.RedisCache\"\n</code></pre> <p>Key changes:</p> django-redis django-cachex <code>CLIENT_CLASS</code> Removed - use specific backend class <code>SERIALIZER</code> <code>serializer</code> (lowercase) <code>COMPRESSOR</code> <code>compressor</code> (lowercase) <code>CONNECTION_POOL_CLASS</code> <code>pool_class</code> <code>get_redis_connection()</code> <code>cache.get_client()</code> <p>Import paths: <code>django_redis.*</code> \u2192 <code>django_cachex.*</code></p> <p>For Sentinel: Use <code>django_cachex.cache.RedisSentinelCache</code> instead of <code>CLIENT_CLASS</code>.</p>"},{"location":"migration/#new-features","title":"New Features","text":"<p>After migrating, you gain:</p> <ul> <li>Unified Valkey + Redis support in one package</li> <li>Multi-serializer/compressor fallback for safe migrations</li> <li>Extended data structures (hashes, lists, sets, sorted sets) directly on cache</li> <li>TTL operations (<code>ttl()</code>, <code>pttl()</code>, <code>expire()</code>, <code>persist()</code>)</li> <li>Pattern operations (<code>keys()</code>, <code>iter_keys()</code>, <code>delete_pattern()</code>)</li> <li>Distributed locking (<code>cache.lock()</code>)</li> <li>Pipelines (<code>cache.pipeline()</code>)</li> </ul>"},{"location":"recipes/","title":"Recipes","text":"<p>Practical solutions for common caching scenarios.</p>"},{"location":"recipes/#session-storage","title":"Session Storage","text":"<p>Use Valkey/Redis for Django sessions:</p> <pre><code># settings.py\nSESSION_ENGINE = \"django.contrib.sessions.backends.cache\"\nSESSION_CACHE_ALIAS = \"default\"\n\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",\n        \"LOCATION\": \"valkey://127.0.0.1:6379/0\",\n    }\n}\n</code></pre> <p>For dedicated session storage with longer TTL:</p> <pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",\n        \"LOCATION\": \"valkey://127.0.0.1:6379/0\",\n    },\n    \"sessions\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",\n        \"LOCATION\": \"valkey://127.0.0.1:6379/1\",\n        \"TIMEOUT\": 86400 * 14,  # 2 weeks\n    },\n}\n\nSESSION_CACHE_ALIAS = \"sessions\"\n</code></pre>"},{"location":"recipes/#rate-limiting","title":"Rate Limiting","text":"<p>Simple rate limiter using sorted sets:</p> <pre><code>import time\nfrom django.core.cache import cache\n\ndef is_rate_limited(user_id: str, limit: int = 100, window: int = 60) -&gt; bool:\n    \"\"\"Check if user has exceeded rate limit.\n\n    Args:\n        user_id: Unique identifier for the user\n        limit: Maximum requests allowed in window\n        window: Time window in seconds\n\n    Returns:\n        True if rate limited, False otherwise\n    \"\"\"\n    key = f\"ratelimit:{user_id}\"\n    now = time.time()\n    window_start = now - window\n\n    pipe = cache.pipeline()\n    # Remove old entries\n    pipe.zremrangebyscore(key, 0, window_start)\n    # Add current request\n    pipe.zadd(key, {str(now): now})\n    # Count requests in window\n    pipe.zcard(key)\n    # Set expiry\n    pipe.expire(key, window)\n    results = pipe.execute()\n\n    count = results[2]\n    return count &gt; limit\n</code></pre>"},{"location":"recipes/#cache-invalidation-patterns","title":"Cache Invalidation Patterns","text":""},{"location":"recipes/#pattern-based-deletion","title":"Pattern-based deletion","text":"<p>Delete all keys matching a pattern:</p> <pre><code>from django.core.cache import cache\n\n# Delete all user-related cache entries\ncache.delete_pattern(\"user:*\")\n\n# Delete all cached API responses\ncache.delete_pattern(\"api:*:response\")\n</code></pre>"},{"location":"recipes/#versioned-cache-keys","title":"Versioned cache keys","text":"<p>Invalidate entire cache groups by incrementing version:</p> <pre><code>from django.core.cache import cache\n\ndef get_user_cache_version(user_id: int) -&gt; int:\n    \"\"\"Get current cache version for a user.\"\"\"\n    return cache.get(f\"user:{user_id}:version\", 1)\n\ndef invalidate_user_cache(user_id: int) -&gt; None:\n    \"\"\"Invalidate all cached data for a user.\"\"\"\n    cache.incr(f\"user:{user_id}:version\")\n\ndef get_user_data(user_id: int) -&gt; dict:\n    \"\"\"Get user data with versioned caching.\"\"\"\n    version = get_user_cache_version(user_id)\n    key = f\"user:{user_id}:data:v{version}\"\n\n    data = cache.get(key)\n    if data is None:\n        data = fetch_user_data_from_db(user_id)\n        cache.set(key, data, timeout=3600)\n    return data\n</code></pre>"},{"location":"recipes/#distributed-locking","title":"Distributed Locking","text":"<p>Prevent concurrent execution of critical sections:</p> <pre><code>from django.core.cache import cache\n\nwith cache.lock(\"process-payments\", timeout=30):\n    process_pending_payments()\n</code></pre>"},{"location":"recipes/#development-without-a-server","title":"Development Without a Server","text":"<p>For local development without a running server, fakeredis provides an in-memory implementation:</p> <pre><code># settings_dev.py\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.RedisCache\",\n        \"LOCATION\": \"redis://localhost:6379/0\",\n        \"OPTIONS\": {\n            \"pool_class\": \"fakeredis.FakeConnectionPool\",\n        },\n    }\n}\n</code></pre> <p>For testing</p> <p>django-cachex uses testcontainers for its test suite. Consider using the same approach for accurate behavior in your tests.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12+</li> <li>Django 5.2+</li> <li>valkey-py 6.1+ or redis-py 6+</li> <li>Valkey server 7+ or Redis server 6+</li> </ul>"},{"location":"getting-started/installation/#install-with-uv","title":"Install with uv","text":"<pre><code>uv add django-cachex\n</code></pre>"},{"location":"getting-started/installation/#install-with-libvalkeyhiredis-recommended","title":"Install with libvalkey/hiredis (recommended)","text":"<p>For better performance, install with the libvalkey (for Valkey) or hiredis (for Redis) parser:</p> <pre><code># For Valkey\nuv add django-cachex[libvalkey]\n\n# For Redis\nuv add django-cachex[hiredis]\n</code></pre> <p>These provide C-based parsers that significantly improve performance.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":""},{"location":"getting-started/quickstart/#configure-as-cache-backend","title":"Configure as Cache Backend","text":"<pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",\n        \"LOCATION\": \"valkey://127.0.0.1:6379/1\",\n    }\n}\n</code></pre>"},{"location":"getting-started/quickstart/#backend-classes","title":"Backend Classes","text":"Backend Description <code>ValkeyCache</code> Standard Valkey connection <code>RedisCache</code> Standard Redis connection <code>ValkeySentinelCache</code> Valkey Sentinel high availability <code>RedisSentinelCache</code> Redis Sentinel high availability <code>ValkeyClusterCache</code> Valkey Cluster sharding <code>RedisClusterCache</code> Redis Cluster sharding <p>Valkey and Redis Compatibility</p> <p>Valkey and Redis are protocol-compatible, so either backend works with either server. Valkey is recommended as it remains fully open source.</p>"},{"location":"getting-started/quickstart/#connection-url-formats","title":"Connection URL Formats","text":"<p>Uses the valkey-py/redis-py native URL notation:</p> <ul> <li><code>valkey://[[username]:[password]]@localhost:6379/0</code> - Valkey TCP connection</li> <li><code>redis://[[username]:[password]]@localhost:6379/0</code> - Redis TCP connection</li> <li><code>valkeys://[[username]:[password]]@localhost:6379/0</code> - Valkey SSL/TLS connection</li> <li><code>rediss://[[username]:[password]]@localhost:6379/0</code> - Redis SSL/TLS connection</li> <li><code>unix://[[username]:[password]]@/path/to/socket.sock?db=0</code> - Unix socket</li> </ul>"},{"location":"getting-started/quickstart/#database-selection","title":"Database Selection","text":"<p>Two ways to specify the database number:</p> <ol> <li>Query string: <code>valkey://localhost?db=0</code></li> <li>Path (for <code>valkey://</code> or <code>redis://</code> scheme): <code>valkey://localhost/0</code></li> </ol>"},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":"<pre><code>from django.core.cache import cache\n\n# Standard Django cache methods\ncache.set(\"key\", \"value\", timeout=300)\nvalue = cache.get(\"key\")\n\n# Extended data structure methods\ncache.hset(\"user:1\", \"name\", \"Alice\")\ncache.zrange(\"leaderboard\", 0, 10)\n\n# Async versions (standard Django methods)\nawait cache.aget(\"key\")\nawait cache.aset(\"key\", \"value\", timeout=300)\n</code></pre>"},{"location":"getting-started/quickstart/#raw-client-access","title":"Raw Client Access","text":"<p>For operations not exposed by the cache interface:</p> <pre><code>client = cache.get_client()\nclient.publish(\"channel\", \"message\")\n</code></pre>"},{"location":"reference/api/","title":"API Reference","text":""},{"location":"reference/api/#cache-methods","title":"Cache Methods","text":""},{"location":"reference/api/#standard-django-cache-methods","title":"Standard Django Cache Methods","text":"<p>All standard Django cache methods are supported:</p> Method Description <code>get(key, default=None)</code> Get a value <code>set(key, value, timeout=DEFAULT)</code> Set a value <code>add(key, value, timeout=DEFAULT)</code> Set only if key doesn't exist <code>delete(key)</code> Delete a key <code>touch(key, timeout=DEFAULT)</code> Update timeout on a key <code>get_many(keys)</code> Get multiple values <code>set_many(mapping, timeout=DEFAULT)</code> Set multiple values <code>delete_many(keys)</code> Delete multiple keys <code>get_or_set(key, default, timeout=DEFAULT)</code> Get value or set default <code>clear()</code> Clear the cache <code>has_key(key)</code> Check if key exists <code>incr(key, delta=1)</code> Increment a value <code>decr(key, delta=1)</code> Decrement a value <code>incr_version(key, delta=1)</code> Increment key version <code>decr_version(key, delta=1)</code> Decrement key version <code>close()</code> Close connections"},{"location":"reference/api/#extended-methods","title":"Extended Methods","text":"<p>django-cachex adds these extended methods:</p> Method Description <code>ttl(key)</code> Get TTL in seconds (<code>None</code> = no expiry, <code>-2</code> = not found) <code>pttl(key)</code> Get TTL in milliseconds (<code>None</code> = no expiry, <code>-2</code> = not found) <code>expire(key, timeout)</code> Set expiration in seconds <code>pexpire(key, timeout)</code> Set expiration in milliseconds <code>expire_at(key, when)</code> Set expiration at datetime <code>pexpire_at(key, when)</code> Set expiration at datetime (ms precision) <code>persist(key)</code> Remove expiration <code>type(key)</code> Get the data type of a key <code>lock(key, ...)</code> Get a distributed lock <code>keys(pattern)</code> Get keys matching pattern <code>iter_keys(pattern)</code> Iterate keys matching pattern <code>scan(cursor, pattern, count)</code> Single SCAN iteration <code>delete_pattern(pattern)</code> Delete keys matching pattern <code>rename(src, dst)</code> Rename a key <code>renamenx(src, dst)</code> Rename key only if dest doesn't exist"},{"location":"reference/api/#hash-methods","title":"Hash Methods","text":"<p>Hash operations for field-value data structures:</p> Method Description <code>hset(key, field, value)</code> Set a hash field value <code>hdel(key, *fields)</code> Delete hash field(s) <code>hexists(key, field)</code> Check if hash field exists <code>hget(key, field)</code> Get a hash field value <code>hgetall(key)</code> Get all fields and values in a hash <code>hkeys(key)</code> Get all field names in a hash <code>hincrby(key, field, amount=1)</code> Increment hash field by integer <code>hincrbyfloat(key, field, amount=1.0)</code> Increment hash field by float <code>hlen(key)</code> Get number of fields in hash <code>hmget(key, *fields)</code> Get multiple hash field values <code>hmset(key, mapping)</code> Set multiple hash fields <code>hsetnx(key, field, value)</code> Set hash field only if it doesn't exist <code>hvals(key)</code> Get all values in a hash"},{"location":"reference/api/#set-methods","title":"Set Methods","text":"<p>Set operations for unordered collections of unique elements:</p> Method Description <code>sadd(key, *members)</code> Add member(s) to set <code>srem(key, *members)</code> Remove member(s) from set <code>smembers(key)</code> Get all members of set <code>sismember(key, member)</code> Check if member exists in set <code>smismember(key, *members)</code> Check if multiple members exist <code>scard(key)</code> Get number of members <code>spop(key, count=None)</code> Remove and return random member(s) <code>srandmember(key, count=None)</code> Get random member(s) without removing <code>smove(src, dst, member)</code> Move member between sets <code>sdiff(*keys)</code> Get difference of sets <code>sdiffstore(dest, *keys)</code> Store difference of sets <code>sinter(*keys)</code> Get intersection of sets <code>sinterstore(dest, *keys)</code> Store intersection of sets <code>sunion(*keys)</code> Get union of sets <code>sunionstore(dest, *keys)</code> Store union of sets <code>sscan(key, cursor=0, ...)</code> Incrementally iterate set members <code>sscan_iter(key, ...)</code> Iterate over set members using SSCAN"},{"location":"reference/api/#sorted-set-methods","title":"Sorted Set Methods","text":"<p>Sorted set operations for scored, ordered collections:</p> Method Description <code>zadd(key, mapping, *, nx, xx, ch, gt, lt)</code> Add member(s) with scores <code>zcard(key)</code> Get number of members <code>zcount(key, min, max)</code> Count members with scores in range <code>zincrby(key, amount, member)</code> Increment member's score <code>zrange(key, start, end, ...)</code> Get members by index range <code>zrevrange(key, start, end, ...)</code> Get members by index range (descending) <code>zrangebyscore(key, min, max, ...)</code> Get members by score range <code>zrevrangebyscore(key, max, min, ...)</code> Get members by score range (descending) <code>zrank(key, member)</code> Get member's rank (ascending) <code>zrevrank(key, member)</code> Get member's rank (descending) <code>zrem(key, *members)</code> Remove member(s) <code>zremrangebyrank(key, start, end)</code> Remove members by rank range <code>zremrangebyscore(key, min, max)</code> Remove members by score range <code>zscore(key, member)</code> Get member's score <code>zmscore(key, *members)</code> Get multiple members' scores <code>zpopmin(key, count=1)</code> Remove and return members with lowest scores <code>zpopmax(key, count=1)</code> Remove and return members with highest scores"},{"location":"reference/api/#list-methods","title":"List Methods","text":"<p>List operations for ordered, indexable collections:</p> Method Description <code>llen(key)</code> Get list length <code>lpush(key, *values)</code> Prepend value(s) to list <code>rpush(key, *values)</code> Append value(s) to list <code>lpop(key)</code> Remove and return first element <code>rpop(key)</code> Remove and return last element <code>lindex(key, index)</code> Get element by index <code>lrange(key, start, end)</code> Get elements in range <code>lset(key, index, value)</code> Set element at index <code>ltrim(key, start, end)</code> Trim list to range <code>lrem(key, count, value)</code> Remove elements equal to value <code>lpos(key, value, ...)</code> Find element position in list <code>linsert(key, where, pivot, value)</code> Insert value before or after pivot <code>lmove(src, dst, wherefrom, whereto)</code> Atomically move element between lists <code>blpop(*keys, timeout=0)</code> Blocking pop from head of list <code>brpop(*keys, timeout=0)</code> Blocking pop from tail of list <code>blmove(src, dst, timeout, ...)</code> Blocking move between lists"},{"location":"reference/api/#lua-script-methods","title":"Lua Script Methods","text":"<p>Execute Lua scripts with optional key prefixing and value encoding/decoding:</p> Method Description <code>eval_script(script, *, keys, args, ...)</code> Execute a Lua script <code>aeval_script(script, *, keys, args, ...)</code> Execute a Lua script (async)"},{"location":"reference/api/#eval_script-aeval_script","title":"eval_script / aeval_script","text":"<pre><code>result = cache.eval_script(\n    script,           # Lua script source code\n    keys=(),          # KEYS to pass to script\n    args=(),          # ARGV to pass to script\n    pre_hook=None,    # Pre-processing hook: (helpers, keys, args) -&gt; (keys, args)\n    post_hook=None,   # Post-processing hook: (helpers, result) -&gt; result\n    version=None,     # Key version for prefixing\n)\n</code></pre>"},{"location":"reference/api/#pre-built-hooks","title":"Pre-built Hooks","text":"Hook Description <code>keys_only_pre</code> Prefix keys, leave args unchanged <code>full_encode_pre</code> Prefix keys AND encode all args <code>decode_single_post</code> Decode a single returned value <code>decode_list_post</code> Decode a list of returned values <code>decode_list_or_none_post</code> Decode list or return None <code>noop_post</code> Return result unchanged"},{"location":"reference/api/#scripthelpers","title":"ScriptHelpers","text":"<p>The helpers object passed to pre/post hooks:</p> Attribute/Method Description <code>make_key(key, version)</code> Apply cache key prefix <code>make_keys(keys)</code> Prefix multiple keys <code>encode(value)</code> Encode a value (serialize + compress) <code>encode_values(values)</code> Encode multiple values <code>decode(value)</code> Decode a value <code>decode_values(values)</code> Decode multiple values <code>version</code> Current key version"},{"location":"reference/api/#set-method-options","title":"Set Method Options","text":"<pre><code>cache.set(key, value, timeout=300, nx=False, xx=False)\n</code></pre> Parameter Description <code>timeout</code> Expiration in seconds (<code>None</code> = never, <code>0</code> = immediate) <code>nx</code> Only set if key doesn't exist (SETNX) <code>xx</code> Only set if key exists"},{"location":"reference/api/#async-methods","title":"Async Methods","text":"<p>Standard Django cache methods have async versions on the cache object:</p> <pre><code># Sync\nvalue = cache.get(\"key\")\n\n# Async\nvalue = await cache.aget(\"key\")\n</code></pre> <ul> <li><code>aadd</code>, <code>aget</code>, <code>aset</code>, <code>adelete</code>, <code>atouch</code>, <code>aget_many</code>, <code>aset_many</code>, <code>adelete_many</code></li> <li><code>ahas_key</code>, <code>aincr</code>, <code>adecr</code>, <code>aget_or_set</code>, <code>aclear</code>, <code>aclose</code></li> <li><code>aincr_version</code>, <code>adecr_version</code></li> <li><code>aeval_script</code></li> </ul> <p>Extended methods (data structures, TTL, patterns) have async versions on the cache client, accessible via <code>cache._cache</code>:</p> <pre><code># Sync (on cache object directly)\ncache.hset(\"hash\", \"field\", \"value\")\n\n# Async (on cache client -- note: client methods use raw/prefixed keys)\nkey = cache.make_and_validate_key(\"hash\")\nawait cache._cache.ahset(key, \"field\", \"value\")\n</code></pre> <ul> <li><code>attl</code>, <code>apttl</code>, <code>aexpire</code>, <code>apexpire</code>, <code>aexpireat</code>, <code>apexpireat</code>, <code>apersist</code></li> <li><code>akeys</code>, <code>aiter_keys</code>, <code>adelete_pattern</code></li> <li><code>ahset</code>, <code>ahdel</code>, <code>ahexists</code>, <code>ahget</code>, <code>ahgetall</code>, <code>ahincrby</code>, <code>ahincrbyfloat</code>, <code>ahkeys</code>, <code>ahlen</code>, <code>ahmget</code>, <code>ahmset</code>, <code>ahsetnx</code>, <code>ahvals</code></li> <li><code>asadd</code>, <code>asrem</code>, <code>asmembers</code>, <code>asismember</code>, <code>asmismember</code>, <code>ascard</code>, <code>aspop</code>, <code>asrandmember</code>, <code>asmove</code>, <code>asdiff</code>, <code>asdiffstore</code>, <code>asinter</code>, <code>asinterstore</code>, <code>asunion</code>, <code>asunionstore</code></li> <li><code>azadd</code>, <code>azcard</code>, <code>azcount</code>, <code>azincrby</code>, <code>azrange</code>, <code>azrevrange</code>, <code>azrangebyscore</code>, <code>azrevrangebyscore</code>, <code>azrank</code>, <code>azrevrank</code>, <code>azrem</code>, <code>azremrangebyrank</code>, <code>azremrangebyscore</code>, <code>azscore</code>, <code>azmscore</code>, <code>azpopmin</code>, <code>azpopmax</code></li> <li><code>allen</code>, <code>alpush</code>, <code>arpush</code>, <code>alpop</code>, <code>arpop</code>, <code>alindex</code>, <code>alrange</code>, <code>alset</code>, <code>altrim</code>, <code>alrem</code>, <code>alpos</code>, <code>almove</code>, <code>alinsert</code>, <code>ablpop</code>, <code>abrpop</code>, <code>ablmove</code></li> </ul>"},{"location":"reference/api/#raw-client-access","title":"Raw Client Access","text":"<pre><code>client = cache.get_client(write=True)\n</code></pre> Parameter Description <code>write</code> Get write connection for primary (default: <code>False</code>) <p>Returns the underlying <code>valkey.Valkey</code> or <code>redis.Redis</code> client instance.</p>"},{"location":"reference/api/#lock-interface","title":"Lock Interface","text":"<pre><code>lock = cache.lock(key, timeout=None, sleep=0.1, blocking=True, blocking_timeout=None)\n</code></pre> Parameter Description <code>key</code> Lock name <code>timeout</code> Lock auto-release timeout <code>sleep</code> Time between acquire attempts <code>blocking</code> Wait for lock if held <code>blocking_timeout</code> Max wait time for lock <p>Compatible with <code>threading.Lock</code>:</p> <pre><code># Context manager\nwith cache.lock(\"mylock\"):\n    do_work()\n\n# Manual acquire/release\nlock = cache.lock(\"mylock\")\nif lock.acquire():\n    try:\n        do_work()\n    finally:\n        lock.release()\n</code></pre>"},{"location":"reference/api/#pipelines","title":"Pipelines","text":"<p>Batch multiple operations for efficiency:</p> <pre><code>pipe = cache.pipeline()\npipe.set(\"key1\", \"value1\")\npipe.set(\"key2\", \"value2\")\npipe.hset(\"hash\", \"field\", \"value\")\nresults = pipe.execute()\n</code></pre> <p>All cache methods are available on the pipeline. Results are returned as a list in the same order as the commands.</p>"},{"location":"reference/api/#settings-reference","title":"Settings Reference","text":""},{"location":"reference/api/#cache-options","title":"Cache OPTIONS","text":"Option Description <code>serializer</code> Serializer class or list for fallback <code>compressor</code> Compressor class or list for fallback <code>password</code> Server password <code>socket_connect_timeout</code> Connection timeout <code>socket_timeout</code> Read/write timeout <code>ignore_exceptions</code> Ignore connection errors <code>log_ignored_exceptions</code> Log ignored exceptions <code>pool_class</code> Custom connection pool class <code>max_connections</code> Maximum pool connections <code>sentinels</code> Sentinel server list (for Sentinel backends) <code>sentinel_kwargs</code> Sentinel configuration"},{"location":"reference/changelog/","title":"Changelog","text":""},{"location":"reference/changelog/#020-february-2026","title":"0.2.0 (February 2026)","text":"<ul> <li>Django permissions enforced: The admin now uses Django's built-in permission system for granular access control. Staff users need explicit permissions; superusers are unaffected.</li> </ul>"},{"location":"reference/changelog/#010-february-2026","title":"0.1.0 (February 2026)","text":"<p>Initial stable release of django-cachex.</p>"},{"location":"reference/changelog/#features","title":"Features","text":"<ul> <li>Unified Valkey + Redis support in one package</li> <li>Full-featured cache backend for Django</li> <li>Session backend support via Django's cache sessions</li> <li>Pluggable clients (Default, Sentinel, Cluster)</li> <li>Pluggable serializers (Pickle, JSON, MsgPack)</li> <li>Pluggable compressors (Zlib, Gzip, LZMA, LZ4, Zstandard)</li> <li>Multi-serializer/compressor fallback for safe migrations</li> <li>Connection pooling with configurable options</li> <li>Primary/replica replication support</li> <li>Valkey/Redis Sentinel support for high availability</li> <li>Valkey/Redis Cluster support with automatic slot handling</li> <li>Distributed locks compatible with <code>threading.Lock</code></li> <li>TTL operations (<code>ttl()</code>, <code>pttl()</code>, <code>expire()</code>, <code>persist()</code>)</li> <li>Pattern operations (<code>keys()</code>, <code>iter_keys()</code>, <code>delete_pattern()</code>)</li> <li>Pipelines for batched operations</li> <li>Lua script interface with automatic key prefixing and value encoding/decoding</li> <li>Django Cache Admin for cache inspection and management</li> <li>Browse, search, edit, and delete cache keys</li> <li>View server info, memory statistics, and slowlog</li> <li>Key type filter sidebar</li> <li>Support for Django builtin backends (LocMemCache, DatabaseCache, FileBasedCache) via wrappers</li> <li>Django Unfold theme support (<code>django_cachex.unfold</code>)</li> <li>Async support for all extended methods</li> </ul>"},{"location":"reference/changelog/#data-structure-operations","title":"Data Structure Operations","text":"<ul> <li>Hash operations: <code>hset</code>, <code>hdel</code>, <code>hexists</code>, <code>hget</code>, <code>hgetall</code>, <code>hincrby</code>, <code>hincrbyfloat</code>, <code>hkeys</code>, <code>hlen</code>, <code>hmget</code>, <code>hmset</code>, <code>hsetnx</code>, <code>hvals</code></li> <li>Sorted set operations: <code>zadd</code>, <code>zcard</code>, <code>zcount</code>, <code>zincrby</code>, <code>zrange</code>, <code>zrevrange</code>, <code>zrangebyscore</code>, <code>zrevrangebyscore</code>, <code>zrank</code>, <code>zrevrank</code>, <code>zrem</code>, <code>zremrangebyrank</code>, <code>zremrangebyscore</code>, <code>zscore</code>, <code>zmscore</code>, <code>zpopmin</code>, <code>zpopmax</code></li> <li>List operations: <code>llen</code>, <code>lpush</code>, <code>rpush</code>, <code>lpop</code>, <code>rpop</code>, <code>lindex</code>, <code>lrange</code>, <code>lset</code>, <code>ltrim</code>, <code>lrem</code>, <code>lpos</code>, <code>linsert</code>, <code>lmove</code>, <code>blpop</code>, <code>brpop</code>, <code>blmove</code></li> <li>Set operations: <code>sadd</code>, <code>srem</code>, <code>smembers</code>, <code>sismember</code>, <code>smismember</code>, <code>scard</code>, <code>spop</code>, <code>srandmember</code>, <code>smove</code>, <code>sdiff</code>, <code>sdiffstore</code>, <code>sinter</code>, <code>sinterstore</code>, <code>sunion</code>, <code>sunionstore</code>, <code>sscan</code>, <code>sscan_iter</code></li> </ul>"},{"location":"reference/changelog/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12+</li> <li>Django 5.2+</li> <li>valkey-py 6.1+ or redis-py 6+</li> </ul>"},{"location":"reference/changelog/#pre-release-history","title":"Pre-release History","text":""},{"location":"reference/changelog/#010b6-february-2026","title":"0.1.0b6 (February 2026)","text":""},{"location":"reference/changelog/#new-features","title":"New Features","text":"<ul> <li>Key type filter: Filter keys by type (string, list, set, hash, zset, stream) in the admin key list sidebar</li> <li>LocMemCache data structure operations: List, set, and hash operations now work with LocMemCache wrappers</li> <li>LocMemCache type detection: Automatically detects stored Python types (list, set, dict) and maps them to Redis equivalents</li> <li><code>KeyType</code> StrEnum: Centralized enum for Redis key types, replacing scattered string literals</li> </ul>"},{"location":"reference/changelog/#improvements","title":"Improvements","text":"<ul> <li>Major admin refactoring: replaced service layer with helpers module, simplified views, restructured templates</li> <li>Unified admin views between classic Django admin and Unfold theme</li> <li>Added <code>_cachex_support</code> ClassVar to <code>CacheProtocol</code> for standardized support level detection</li> <li>Mixin-based class patching for cache wrappers (replacing intermediate extension classes)</li> <li>Extensive dead code cleanup across the codebase</li> </ul>"},{"location":"reference/changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Fixed unfold template differences with classic admin</li> <li>Fixed <code>key_type</code> variable usage in unfold key detail template</li> <li>Fixed mypy and ty type-checking errors</li> <li>Fixed <code>!r</code> format spec for <code>KeyT</code> in error messages</li> </ul>"},{"location":"reference/changelog/#010b5-february-2026","title":"0.1.0b5 (February 2026)","text":""},{"location":"reference/changelog/#new-features_1","title":"New Features","text":"<ul> <li>Expanded cache backend support: The admin interface now supports Django's builtin cache backends through wrapper classes</li> <li><code>LocMemCache</code>: Full support including key listing, TTL inspection, and memory statistics</li> <li><code>DatabaseCache</code>: Key listing, TTL inspection, and database statistics</li> <li><code>FileBasedCache</code>: File listing (as MD5 hashes) and disk usage statistics</li> <li><code>Memcached</code>: Basic stats when available</li> <li>Django's <code>RedisCache</code>: Basic support (full features require django-cachex backends)</li> </ul>"},{"location":"reference/changelog/#improvements_1","title":"Improvements","text":"<ul> <li>Standardized <code>info()</code> output format across all wrapped cache backends</li> <li>Added TTL support (<code>ttl()</code>, <code>expire()</code>, <code>persist()</code>) for LocMemCache</li> <li>Improved cache admin UX: operations that aren't supported now fail gracefully instead of hiding UI elements</li> </ul>"},{"location":"reference/changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Fixed LocMemCache keys showing \"not found\" when clicked in admin</li> <li>Fixed cache query parameter preservation in key search form</li> <li>Fixed editing for wrapped cache backends</li> </ul>"},{"location":"reference/changelog/#010b4-january-2026","title":"0.1.0b4 (January 2026)","text":""},{"location":"reference/changelog/#new-features_2","title":"New Features","text":"<ul> <li>Django Cache Admin: Built-in admin interface for cache management</li> <li>Browse all configured caches</li> <li>Search keys with wildcard patterns</li> <li>View and edit cache values (strings, hashes, lists, sets, sorted sets)</li> <li>Inspect TTL and modify expiration</li> <li>View server info and memory statistics</li> <li>Flush individual caches</li> <li> <p>Bulk delete keys</p> </li> <li> <p>Django Unfold Theme Support: Alternative admin styling for django-unfold users</p> </li> <li>Use <code>django_cachex.unfold</code> instead of <code>django_cachex.admin</code></li> <li> <p>Consistent styling with Unfold's modern admin theme</p> </li> <li> <p>Example Projects: Added example projects demonstrating various configurations</p> </li> <li><code>examples/simple/</code> - Basic setup with ValkeyCache and LocMemCache</li> <li><code>examples/full/</code> - Multiple backends including Sentinel and Cluster</li> <li><code>examples/unfold/</code> - Django Unfold theme integration</li> </ul>"},{"location":"reference/changelog/#010b3-january-2026","title":"0.1.0b3 (January 2026)","text":""},{"location":"reference/changelog/#new-features_3","title":"New Features","text":"<ul> <li>Lua Script Interface: High-level API for registering and executing Lua scripts with automatic key prefixing and value encoding/decoding</li> <li><code>cache.register_script()</code> to register scripts with pre/post processing hooks</li> <li><code>cache.eval_script()</code> and <code>cache.aeval_script()</code> for sync/async execution</li> <li><code>pipe.eval_script()</code> for pipeline support</li> <li>Pre-built helpers: <code>keys_only_pre</code>, <code>full_encode_pre</code>, <code>decode_single_post</code>, <code>decode_list_post</code></li> <li><code>ScriptHelpers</code> class exposes <code>make_key</code>, <code>encode</code>, <code>decode</code> for custom hooks</li> <li>Automatic SHA caching with NOSCRIPT fallback</li> </ul>"},{"location":"user-guide/admin/","title":"Cache Admin","text":"<p>django-cachex provides a Django admin interface for browsing cache keys, viewing values, and adding, editing, or deleting entries.</p>"},{"location":"user-guide/admin/#installation","title":"Installation","text":""},{"location":"user-guide/admin/#standard-django-admin","title":"Standard Django Admin","text":"<p>Add <code>django_cachex.admin</code> to your <code>INSTALLED_APPS</code>:</p> <pre><code>INSTALLED_APPS = [\n    # ... other apps\n    \"django.contrib.admin\",\n    \"django_cachex.admin\",  # Cache admin interface\n]\n</code></pre> <p>The cache admin will appear in the Django admin sidebar under \"Caches\".</p>"},{"location":"user-guide/admin/#django-unfold-theme","title":"Django Unfold Theme","text":"<p>For users of django-unfold, use <code>django_cachex.unfold</code> instead:</p> <pre><code>INSTALLED_APPS = [\n    # django-unfold must be before django.contrib.admin\n    \"unfold\",\n    \"unfold.contrib.filters\",\n    \"unfold.contrib.forms\",\n    # Django apps\n    \"django.contrib.admin\",\n    # ...\n    \"django_cachex.unfold\",  # Unfold-styled cache admin\n]\n</code></pre> <p>Install the unfold extra:</p> <pre><code>pip install django-cachex[unfold]\n</code></pre> <p>Choose One</p> <p>Use either <code>django_cachex.admin</code> OR <code>django_cachex.unfold</code>, not both. They provide the same functionality with different styling.</p>"},{"location":"user-guide/admin/#permissions","title":"Permissions","text":"<p>The admin uses Django's built-in permission system. Superusers have full access. Staff users need explicit permissions:</p> <ul> <li><code>django_cachex.view_cache</code> / <code>view_key</code> \u2014 view caches and keys</li> <li><code>django_cachex.change_cache</code> \u2014 flush caches, update TTL</li> <li><code>django_cachex.add_key</code> \u2014 create keys</li> <li><code>django_cachex.change_key</code> \u2014 edit values</li> <li><code>django_cachex.delete_key</code> \u2014 delete keys</li> </ul>"},{"location":"user-guide/admin/#support-levels","title":"Support Levels","text":"<p>Different cache backends have different levels of support:</p> Badge Level Description cachex Full Support django-cachex backends (<code>ValkeyCache</code>, <code>RedisCache</code>, etc.) -- all features including key listing, pattern search, TTL inspection, and data type operations. wrapped Wrapped Support Django builtin backends (<code>LocMemCache</code>, <code>DatabaseCache</code>, etc.) -- most features available through wrapper compatibility. limited Limited Support Custom or unknown backends -- basic operations may work but key listing and advanced features may not be available."},{"location":"user-guide/admin/#using-redisvalkey","title":"Using Redis/Valkey?","text":"<p>If you are using Django's builtin Redis backend (<code>django.core.cache.backends.redis.RedisCache</code>), consider switching to django-cachex's <code>ValkeyCache</code> or <code>RedisCache</code> backends for full admin functionality: key browsing, pattern search, TTL inspection, native data type support, and server statistics. See the quickstart guide for migration instructions.</p>"},{"location":"user-guide/admin/#views","title":"Views","text":""},{"location":"user-guide/admin/#caches-index","title":"Caches (Index)","text":"<p>Lists all configured caches showing name, backend class, location, and support level.</p> <p>Actions: Flush selected caches (delete all entries).</p>"},{"location":"user-guide/admin/#key-browser","title":"Key Browser","text":"<p>Click a cache name to browse its keys with wildcard search (<code>*</code>), data type display, TTL, and pagination.</p> <p>Actions: Delete selected keys, add new key.</p>"},{"location":"user-guide/admin/#key-detail","title":"Key Detail","text":"<p>View and edit a specific key's value (formatted JSON for objects/arrays), data type, and TTL. Supports editing values/timeout and deleting the key.</p>"},{"location":"user-guide/admin/#cache-info","title":"Cache Info","text":"<p>View server information: configuration, server version/uptime, memory usage, connected clients, command statistics, and keyspace data.</p>"},{"location":"user-guide/admin/#add-key","title":"Add Key","text":"<p>Create a new cache entry with key name, value (JSON objects/arrays are parsed automatically), and optional timeout in seconds.</p>"},{"location":"user-guide/admin/#backend-abilities","title":"Backend Abilities","text":"<p>The admin adapts based on backend capabilities:</p> Feature cachex LocMemCache DatabaseCache FileBasedCache limited List keys Yes Yes Yes Yes* No Get key Yes Yes Yes No Yes Delete key Yes Yes Yes No Yes Edit key Yes Yes Yes No Yes Get TTL Yes Yes Yes No No Get type Yes No No No No Cache info Yes Yes Yes Yes No Flush cache Yes Yes Yes Yes Varies <p>*FileBasedCache shows MD5 hashes instead of original key names (one-way hash)</p>"},{"location":"user-guide/admin/#tips","title":"Tips","text":"<ul> <li>Pattern Search: Use <code>*</code> as a wildcard (e.g., <code>user:*</code> finds all keys starting with \"user:\").</li> <li>JSON Values: Enter valid JSON when editing to store objects or arrays.</li> <li>Help Button: Each view has a help button with context-specific tips.</li> <li>Refresh: Use the refresh action to update key lists and statistics.</li> </ul>"},{"location":"user-guide/advanced/","title":"Advanced Usage","text":""},{"location":"user-guide/advanced/#serializer","title":"Serializer","text":"<p>By default, <code>PickleSerializer</code> is used with <code>pickle.DEFAULT_PROTOCOL</code>. To use a different serializer or configure pickle options, use the <code>serializer</code> option:</p> <pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",\n        \"LOCATION\": \"valkey://127.0.0.1:6379/1\",\n        \"OPTIONS\": {\n            \"serializer\": \"django_cachex.serializers.json.JSONSerializer\",\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/advanced/#ttl-operations","title":"TTL Operations","text":""},{"location":"user-guide/advanced/#get-ttl","title":"Get TTL","text":"<pre><code>from django.core.cache import cache\n\ncache.set(\"foo\", \"value\", timeout=25)\ncache.ttl(\"foo\")      # Returns 25\ncache.ttl(\"missing\")  # Returns 0 (key doesn't exist)\n</code></pre> <p>Returns:</p> <ul> <li><code>0</code> - Key doesn't exist or already expired</li> <li><code>None</code> - Key exists but has no expiration</li> <li><code>int</code> - Seconds until expiration</li> </ul>"},{"location":"user-guide/advanced/#get-ttl-in-milliseconds","title":"Get TTL in Milliseconds","text":"<pre><code>cache.set(\"foo\", \"value\", timeout=25)\ncache.pttl(\"foo\")  # Returns 25000\n</code></pre>"},{"location":"user-guide/advanced/#expire-persist","title":"Expire &amp; Persist","text":""},{"location":"user-guide/advanced/#set-expiration","title":"Set Expiration","text":"<pre><code>cache.set(\"foo\", \"bar\", timeout=22)\ncache.expire(\"foo\", timeout=5)\ncache.ttl(\"foo\")  # Returns 5\n</code></pre>"},{"location":"user-guide/advanced/#set-expiration-in-milliseconds","title":"Set Expiration in Milliseconds","text":"<pre><code>cache.set(\"foo\", \"bar\", timeout=22)\ncache.pexpire(\"foo\", timeout=5500)\ncache.pttl(\"foo\")  # Returns 5500\n</code></pre>"},{"location":"user-guide/advanced/#expire-at-specific-time","title":"Expire at Specific Time","text":"<pre><code>from datetime import datetime, timedelta\n\ncache.set(\"foo\", \"bar\", timeout=22)\ncache.expire_at(\"foo\", datetime.now() + timedelta(hours=1))\ncache.ttl(\"foo\")  # Returns ~3600\n</code></pre>"},{"location":"user-guide/advanced/#expire-at-specific-time-milliseconds-precision","title":"Expire at Specific Time (milliseconds precision)","text":"<pre><code>cache.set(\"foo\", \"bar\", timeout=22)\ncache.pexpire_at(\"foo\", datetime.now() + timedelta(milliseconds=900, hours=1))\ncache.pttl(\"foo\")  # Returns ~3600900\n</code></pre>"},{"location":"user-guide/advanced/#remove-expiration","title":"Remove Expiration","text":"<pre><code>cache.set(\"foo\", \"bar\", timeout=22)\ncache.persist(\"foo\")\ncache.ttl(\"foo\")  # Returns None (no expiration)\n</code></pre>"},{"location":"user-guide/advanced/#locks","title":"Locks","text":"<p>Distributed locks with the <code>threading.Lock</code> interface:</p> <pre><code>from django.core.cache import cache\n\nwith cache.lock(\"somekey\"):\n    do_some_thing()\n</code></pre>"},{"location":"user-guide/advanced/#bulk-operations","title":"Bulk Operations","text":""},{"location":"user-guide/advanced/#search-keys","title":"Search Keys","text":"<pre><code>from django.core.cache import cache\n\n# Get all matching keys (not recommended for large datasets)\ncache.keys(\"foo_*\")  # Returns [\"foo_1\", \"foo_2\"]\n</code></pre>"},{"location":"user-guide/advanced/#iterate-keys-recommended","title":"Iterate Keys (Recommended)","text":"<p>For large datasets, use server-side cursors:</p> <pre><code># Returns a generator\nfor key in cache.iter_keys(\"foo_*\"):\n    print(key)\n</code></pre>"},{"location":"user-guide/advanced/#delete-by-pattern","title":"Delete by Pattern","text":"<pre><code>cache.delete_pattern(\"foo_*\")\n</code></pre> <p>For better performance with many keys:</p> <pre><code>cache.delete_pattern(\"foo_*\", itersize=100_000)\n</code></pre>"},{"location":"user-guide/advanced/#atomic-operations","title":"Atomic Operations","text":""},{"location":"user-guide/advanced/#setnx-set-if-not-exists","title":"SETNX (Set if Not Exists)","text":"<pre><code>cache.set(\"key\", \"value1\", nx=True)  # Returns True\ncache.set(\"key\", \"value2\", nx=True)  # Returns False\ncache.get(\"key\")  # Returns \"value1\"\n</code></pre>"},{"location":"user-guide/advanced/#incrementdecrement","title":"Increment/Decrement","text":"<pre><code>cache.set(\"counter\", 0)\ncache.incr(\"counter\")  # Returns 1\ncache.incr(\"counter\", delta=5)  # Returns 6\ncache.decr(\"counter\")  # Returns 5\n</code></pre>"},{"location":"user-guide/advanced/#data-structures","title":"Data Structures","text":"<p>Direct access to Valkey/Redis data structures through the cache interface.</p>"},{"location":"user-guide/advanced/#hashes","title":"Hashes","text":"<p>Maps of field-value pairs:</p> <pre><code>from django.core.cache import cache\n\n# Set a single field\ncache.hset(\"user:1\", \"name\", \"Alice\")\n\n# Set multiple fields at once\ncache.hmset(\"user:1\", {\"email\": \"alice@example.com\", \"age\": 30})\n\n# Get a single field\nname = cache.hget(\"user:1\", \"name\")  # \"Alice\"\n\n# Get multiple fields\nvalues = cache.hmget(\"user:1\", \"name\", \"email\")  # [\"Alice\", \"alice@example.com\"]\n\n# Get all fields and values\nuser = cache.hgetall(\"user:1\")  # {\"name\": \"Alice\", \"email\": \"...\", \"age\": 30}\n\n# Increment a numeric field\ncache.hincrby(\"user:1\", \"age\", 1)  # 31\ncache.hincrbyfloat(\"user:1\", \"score\", 0.5)  # For floating point\n\n# Check if field exists\ncache.hexists(\"user:1\", \"name\")  # True\n\n# Delete fields\ncache.hdel(\"user:1\", \"age\")\n\n# Get count of fields\ncache.hlen(\"user:1\")  # 2\n\n# Get all values\ncache.hvals(\"user:1\")  # [\"Alice\", \"alice@example.com\"]\n</code></pre>"},{"location":"user-guide/advanced/#sorted-sets","title":"Sorted Sets","text":"<p>Unique members with scores, automatically sorted:</p> <pre><code>from django.core.cache import cache\n\n# Add members with scores\ncache.zadd(\"leaderboard\", {\"alice\": 100, \"bob\": 85, \"charlie\": 92})\n\n# Get rank (0-indexed, ascending by score)\ncache.zrank(\"leaderboard\", \"alice\")  # 2 (highest score = last)\ncache.zrevrank(\"leaderboard\", \"alice\")  # 0 (highest score = first)\n\n# Get score\ncache.zscore(\"leaderboard\", \"bob\")  # 85.0\n\n# Get multiple scores\ncache.zmscore(\"leaderboard\", \"alice\", \"bob\")  # [100.0, 85.0]\n\n# Increment score\ncache.zincrby(\"leaderboard\", 10, \"bob\")  # 95.0\n\n# Get range by rank (ascending)\ncache.zrange(\"leaderboard\", 0, -1)  # All members sorted by score\n\n# Get range by rank with scores\ncache.zrange(\"leaderboard\", 0, -1, withscores=True)\n\n# Get range by score\ncache.zrangebyscore(\"leaderboard\", 80, 100)\n\n# Count members in score range\ncache.zcount(\"leaderboard\", 80, 100)  # 3\n\n# Remove members\ncache.zrem(\"leaderboard\", \"charlie\")\n\n# Remove by rank range\ncache.zremrangebyrank(\"leaderboard\", 0, 1)  # Remove lowest 2\n\n# Get total count\ncache.zcard(\"leaderboard\")\n</code></pre>"},{"location":"user-guide/advanced/#lists","title":"Lists","text":"<p>Ordered collections of elements:</p> <pre><code>from django.core.cache import cache\n\n# Push elements\ncache.lpush(\"queue\", \"first\")  # Prepend (left)\ncache.rpush(\"queue\", \"last\")   # Append (right)\n\n# Pop elements\ncache.lpop(\"queue\")  # Remove and return first\ncache.rpop(\"queue\")  # Remove and return last\n\n# Get element by index\ncache.lindex(\"queue\", 0)  # First element\n\n# Get range of elements\ncache.lrange(\"queue\", 0, -1)  # All elements\n\n# Set element at index\ncache.lset(\"queue\", 0, \"new_first\")\n\n# Trim to range\ncache.ltrim(\"queue\", 0, 99)  # Keep first 100 elements\n\n# Get length\ncache.llen(\"queue\")\n\n# Find element position\ncache.lpos(\"queue\", \"target\")  # Returns index or None\n\n# Move element between lists atomically\ncache.lmove(\"source\", \"dest\", \"LEFT\", \"RIGHT\")  # LPOP source, RPUSH dest\n</code></pre>"},{"location":"user-guide/advanced/#raw-client-access","title":"Raw Client Access","text":"<p>Access the underlying valkey-py/redis-py client directly:</p> <pre><code>client = cache.get_client()\nclient.publish(\"channel\", \"message\")\n</code></pre>"},{"location":"user-guide/advanced/#lua-scripts","title":"Lua Scripts","text":"<p>Execute Lua scripts with automatic key prefixing and value encoding/decoding.</p>"},{"location":"user-guide/advanced/#basic-usage","title":"Basic Usage","text":"<pre><code>from django.core.cache import cache\n\n# Simple script\nresult = cache.eval_script(\"return 42\")\n\n# With keys and args\ncount = cache.eval_script(\n    \"return redis.call('INCR', KEYS[1])\",\n    keys=[\"counter\"],\n    args=[],\n)\n</code></pre>"},{"location":"user-guide/advanced/#prepost-processing-hooks","title":"Pre/Post Processing Hooks","text":"<p>Scripts support <code>pre_hook</code> (transform keys/args before execution) and <code>post_hook</code> (transform results after execution).</p>"},{"location":"user-guide/advanced/#built-in-helpers","title":"Built-in Helpers","text":"<pre><code>from django_cachex import (\n    keys_only_pre,      # Prefix keys, leave args unchanged\n    full_encode_pre,    # Prefix keys AND encode args (serialize values)\n    decode_single_post, # Decode a single returned value\n    decode_list_post,   # Decode a list of returned values\n    noop_post,          # Return result unchanged\n)\n</code></pre>"},{"location":"user-guide/advanced/#key-prefixing","title":"Key Prefixing","text":"<pre><code>from django_cachex import keys_only_pre\n\ncount = cache.eval_script(\n    \"\"\"\n    local current = redis.call('INCR', KEYS[1])\n    if current == 1 then\n        redis.call('EXPIRE', KEYS[1], ARGV[1])\n    end\n    return current\n    \"\"\",\n    keys=[\"user:123:requests\"],\n    args=[60],\n    pre_hook=keys_only_pre,\n)\n</code></pre>"},{"location":"user-guide/advanced/#encoding-values","title":"Encoding Values","text":"<pre><code>from django_cachex import full_encode_pre, decode_single_post\n\n# Works with any serializable Python object\nold_session = cache.eval_script(\n    \"\"\"\n    local old = redis.call('GET', KEYS[1])\n    redis.call('SET', KEYS[1], ARGV[1])\n    return old\n    \"\"\",\n    keys=[\"session:abc\"],\n    args=[{\"user_id\": 123, \"permissions\": [\"read\", \"write\"]}],\n    pre_hook=full_encode_pre,\n    post_hook=decode_single_post,\n)\n</code></pre>"},{"location":"user-guide/advanced/#custom-processing-hooks","title":"Custom Processing Hooks","text":"<p>Create custom hooks with <code>ScriptHelpers</code>:</p> <pre><code>from django_cachex import ScriptHelpers\n\ndef my_pre(helpers: ScriptHelpers, keys, args):\n    # First arg is a secondary key, rest are values\n    processed_args = [helpers.make_key(args[0], helpers.version)]\n    processed_args.extend(helpers.encode_values(args[1:]))\n    return helpers.make_keys(keys), processed_args\n\ndef my_post(helpers: ScriptHelpers, result):\n    # Result is [count, list_of_values]\n    return {\n        \"count\": result[0],\n        \"values\": helpers.decode_values(result[1]) if result[1] else [],\n    }\n\nresult = cache.eval_script(\"...\", pre_hook=my_pre, post_hook=my_post)\n</code></pre>"},{"location":"user-guide/advanced/#pipeline-support","title":"Pipeline Support","text":"<p>Scripts can be queued in pipelines:</p> <pre><code>from django_cachex import keys_only_pre\n\nwith cache.pipeline() as pipe:\n    pipe.set(\"key1\", \"value1\")\n    pipe.eval_script(\n        \"return redis.call('INCR', KEYS[1])\",\n        keys=[\"user:1\"],\n        pre_hook=keys_only_pre,\n    )\n    results = pipe.execute()  # [True, 1]\n</code></pre>"},{"location":"user-guide/advanced/#async-support","title":"Async Support","text":"<p>Use <code>aeval_script()</code> for async execution:</p> <p>```python from django_cachex import keys_only_pre</p> <p>count = await cache.aeval_script(     \"\"\"     local current = redis.call('INCR', KEYS[1])     if current == 1 then         redis.call('EXPIRE', KEYS[1], ARGV[1])     end     return current     \"\"\",     keys=[\"user:123:requests\"],     args=[60],     pre_hook=keys_only_pre, )</p>"},{"location":"user-guide/async/","title":"Async Support","text":"<p>django-cachex implements Django's async cache methods (<code>aget</code>, <code>aset</code>, <code>adelete</code>, etc.) using native async clients from <code>redis.asyncio</code> and <code>valkey.asyncio</code>, providing true async operations without thread pool overhead.</p>"},{"location":"user-guide/async/#overview","title":"Overview","text":"<p>A single cache backend supports both sync and async operations simultaneously -- <code>cache.get()</code> and <code>await cache.aget()</code> work on the same backend with no separate configuration needed.</p>"},{"location":"user-guide/async/#basic-usage","title":"Basic Usage","text":"<pre><code>from django.core.cache import cache\n\n# Async views (ASGI)\nasync def my_view(request):\n    # Read\n    value = await cache.aget(\"key\")\n\n    # Write\n    await cache.aset(\"key\", \"value\", timeout=300)\n\n    # Delete\n    await cache.adelete(\"key\")\n\n    # Check existence\n    exists = await cache.ahas_key(\"key\")\n\n    return JsonResponse({\"value\": value})\n</code></pre>"},{"location":"user-guide/async/#available-async-methods","title":"Available Async Methods","text":""},{"location":"user-guide/async/#standard-django-cache-methods","title":"Standard Django Cache Methods","text":"<p>All standard Django cache methods have async equivalents with the <code>a</code> prefix:</p> Sync Async <code>get(key)</code> <code>aget(key)</code> <code>set(key, value, timeout)</code> <code>aset(key, value, timeout)</code> <code>add(key, value, timeout)</code> <code>aadd(key, value, timeout)</code> <code>delete(key)</code> <code>adelete(key)</code> <code>get_many(keys)</code> <code>aget_many(keys)</code> <code>set_many(mapping, timeout)</code> <code>aset_many(mapping, timeout)</code> <code>delete_many(keys)</code> <code>adelete_many(keys)</code> <code>has_key(key)</code> <code>ahas_key(key)</code> <code>incr(key, delta)</code> <code>aincr(key, delta)</code> <code>decr(key, delta)</code> <code>adecr(key, delta)</code> <code>touch(key, timeout)</code> <code>atouch(key, timeout)</code> <code>clear()</code> <code>aclear()</code> <code>close()</code> <code>aclose()</code> <code>get_or_set(key, default, timeout)</code> <code>aget_or_set(key, default, timeout)</code> <code>incr_version(key)</code> <code>aincr_version(key)</code> <code>decr_version(key)</code> <code>adecr_version(key)</code>"},{"location":"user-guide/async/#extended-methods","title":"Extended Methods","text":"<p>django-cachex extended methods also have async versions at the client level (<code>cache._cache</code>):</p> <pre><code>client = cache._cache  # Access the cache client for extended async methods\n\n# TTL operations\nttl = await client.attl(key)             # Get TTL in seconds\npttl = await client.apttl(key)           # Get TTL in milliseconds\nawait client.aexpire(key, timeout=60)    # Set expiration\nawait client.apersist(key)               # Remove expiration\n\n# Key operations\nkeys = await client.akeys(\"pattern:*\")\nawait client.adelete_pattern(\"session:*\")\nawait client.arename(key, new_key)\n\n# Iterate keys (memory-efficient)\nasync for key in client.aiter_keys(\"user:*\"):\n    print(key)\n</code></pre> <p>Key prefixing</p> <p>Client-level methods operate on raw (already-prefixed) keys. Use <code>cache.make_and_validate_key()</code> to prefix keys when calling client methods directly.</p>"},{"location":"user-guide/async/#data-structures","title":"Data Structures","text":"<p>Data structure operations have async equivalents at the client level:</p> <pre><code>client = cache._cache\n\n# Hashes\nawait client.ahset(key, \"name\", \"Alice\")\nname = await client.ahget(key, \"name\")\nuser = await client.ahgetall(key)\n\n# Lists\nawait client.alpush(key, \"item\")\nitem = await client.alpop(key)\nitems = await client.alrange(key, 0, -1)\n\n# Sets\nawait client.asadd(key, \"python\", \"django\")\nmembers = await client.asmembers(key)\nis_member = await client.asismember(key, \"python\")\n\n# Sorted Sets\nawait client.azadd(key, {\"alice\": 100, \"bob\": 85})\nrank = await client.azrank(key, \"alice\")\ntop_players = await client.azrange(key, 0, 9, withscores=True)\n</code></pre>"},{"location":"user-guide/async/#how-it-works","title":"How It Works","text":""},{"location":"user-guide/async/#connection-pool-architecture","title":"Connection Pool Architecture","text":"<p>Separate connection pools are maintained for sync and async operations:</p> <ul> <li>Sync pools: Standard pools (<code>redis.ConnectionPool</code> / <code>valkey.ConnectionPool</code>), one per server</li> <li>Async pools: Async pools (<code>redis.asyncio.ConnectionPool</code> / <code>valkey.asyncio.ConnectionPool</code>), cached per event loop</li> </ul> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Cache Backend                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Sync Pools                 \u2502  Async Pools              \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500               \u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500             \u2502\n\u2502  pools[0] \u2192 server1         \u2502  loop1 \u2192 {0: pool, ...}   \u2502\n\u2502  pools[1] \u2192 server2         \u2502  loop2 \u2192 {0: pool, ...}   \u2502\n\u2502  ...                        \u2502  ...                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"user-guide/async/#per-event-loop-caching","title":"Per-Event-Loop Caching","text":"<p>Async pools are stored in a <code>WeakKeyDictionary</code> keyed by event loop, providing automatic cleanup when loops are garbage collected, thread safety (each loop gets its own pools), and connection reuse within the same loop.</p>"},{"location":"user-guide/async/#performance-considerations","title":"Performance Considerations","text":"<p>Event Loop Lifecycle</p> <p>Async pools are cached per event loop. This is efficient for long-lived loops but wasteful for short-lived ones.</p>"},{"location":"user-guide/async/#efficient-long-lived-event-loops","title":"Efficient: Long-Lived Event Loops","text":"<p>ASGI servers (uvicorn, daphne, hypercorn) maintain long-lived event loops where connections are reused across requests:</p> <pre><code># In an ASGI application - efficient!\nasync def my_view(request):\n    # Connections are reused across requests\n    value = await cache.aget(\"key\")\n    await cache.aset(\"key\", \"new_value\")\n    return JsonResponse({\"value\": value})\n</code></pre>"},{"location":"user-guide/async/#inefficient-short-lived-event-loops","title":"Inefficient: Short-Lived Event Loops","text":"<p>Avoid async methods when event loops are frequently created and destroyed:</p> <pre><code># BAD: Each asyncio.run() creates a new event loop = new connection pool\ndef sync_function():\n    for i in range(100):\n        # Creates 100 connection pools!\n        asyncio.run(cache.aget(f\"key:{i}\"))\n\n# BAD: sync_to_async may create temporary event loops\n@sync_to_async\ndef wrapped_function():\n    # May not reuse connections efficiently\n    pass\n</code></pre>"},{"location":"user-guide/async/#recommendations","title":"Recommendations","text":"Context Recommendation ASGI views (uvicorn, daphne) Use async methods (<code>aget</code>, <code>aset</code>, etc.) WSGI views (gunicorn, uwsgi) Use sync methods (<code>get</code>, <code>set</code>, etc.) Management commands Use sync methods Celery tasks Use sync methods Background tasks with persistent loop Use async methods"},{"location":"user-guide/async/#configuration","title":"Configuration","text":""},{"location":"user-guide/async/#custom-async-pool-class","title":"Custom Async Pool Class","text":"<p>Provide a custom async connection pool class:</p> <pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.RedisCache\",\n        \"LOCATION\": \"redis://127.0.0.1:6379/1\",\n        \"OPTIONS\": {\n            # Custom async pool class (import path or class)\n            \"async_pool_class\": \"myapp.pools.CustomAsyncConnectionPool\",\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/async/#closing-async-connections","title":"Closing Async Connections","text":"<pre><code>await cache.aclose()\n</code></pre> <p>Closes the async connection pool for the current event loop. Sync pools remain open.</p>"},{"location":"user-guide/async/#mixed-syncasync-usage","title":"Mixed Sync/Async Usage","text":"<p>A single backend works for both sync and async code:</p> <pre><code>from django.core.cache import cache\n\n# Sync code path\ndef sync_view(request):\n    value = cache.get(\"key\")           # Uses sync pool\n    cache.set(\"key\", \"value\")\n    return HttpResponse(value)\n\n# Async code path\nasync def async_view(request):\n    value = await cache.aget(\"key\")    # Uses async pool\n    await cache.aset(\"key\", \"value\")\n    return JsonResponse({\"value\": value})\n</code></pre> <p>Both views use the same cache backend configured in settings.</p>"},{"location":"user-guide/async/#cluster-and-sentinel","title":"Cluster and Sentinel","text":"<p>Async works identically with Cluster and Sentinel backends:</p> <pre><code># Cluster - async works the same way\nasync def cluster_example():\n    await cache.aset(\"key\", \"value\")\n    await cache.aget_many([\"key1\", \"key2\", \"key3\"])\n\n# Sentinel - async works the same way\nasync def sentinel_example():\n    await cache.aset(\"key\", \"value\")\n    value = await cache.aget(\"key\")\n</code></pre>"},{"location":"user-guide/async/#complete-example","title":"Complete Example","text":"<pre><code># settings.py\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",\n        \"LOCATION\": \"valkey://127.0.0.1:6379/1\",\n        \"TIMEOUT\": 300,\n        \"OPTIONS\": {\n            \"max_connections\": 50,\n        }\n    }\n}\n\n# views.py\nfrom django.core.cache import cache\nfrom django.http import JsonResponse\n\nasync def user_profile(request, user_id):\n    cache_key = f\"user:{user_id}:profile\"\n\n    # Try cache first\n    profile = await cache.aget(cache_key)\n\n    if profile is None:\n        # Cache miss - fetch from database\n        profile = await get_user_profile_from_db(user_id)\n        await cache.aset(cache_key, profile, timeout=3600)\n\n    return JsonResponse(profile)\n\nasync def leaderboard(request):\n    # Get top 10 from sorted set (descending by score)\n    top_players = cache.zrevrange(\n        \"game:leaderboard\",\n        0, 9,\n        withscores=True,\n    )\n\n    return JsonResponse({\"leaderboard\": top_players})\n</code></pre>"},{"location":"user-guide/cluster/","title":"Valkey/Redis Cluster","text":"<p>For basic cluster setup, see Configuration.</p>"},{"location":"user-guide/cluster/#slot-handling","title":"Slot Handling","text":"<p>Valkey/Redis Cluster distributes keys across 16,384 hash slots. django-cachex handles Django cache methods and direct commands differently:</p> <p>Django cache methods (<code>get_many</code>, <code>set_many</code>, <code>delete_many</code>, <code>keys</code>, <code>clear</code>) are cluster-aware and handle cross-slot operations automatically.</p> <p>Direct commands (sets, lists, hashes, sorted sets) pass through to the server. Multi-key commands (<code>sdiff</code>, <code>sinter</code>, <code>sunion</code>, <code>lmove</code>) require all keys on the same slot.</p>"},{"location":"user-guide/cluster/#hash-tags","title":"Hash Tags","text":"<p>Force keys to the same slot using hash tags (the substring between <code>{</code> and <code>}</code>):</p> <pre><code># Same slot (hash tag is \"user:123\")\ncache.sadd(\"{user:123}:followers\", \"alice\", \"bob\")\ncache.sadd(\"{user:123}:following\", \"charlie\")\n\n# Multi-key operations now work\ncache.sdiff(\"{user:123}:followers\", \"{user:123}:following\")\n</code></pre> <p>Use hash tags when you need:</p> <ul> <li>Multi-key set operations: <code>sdiff</code>, <code>sinter</code>, <code>sunion</code></li> <li>List moves: <code>lmove</code></li> <li>Transactions across multiple keys</li> </ul> <pre><code># Group related keys\n\"{user:123}:profile\"\n\"{user:123}:settings\"\n\"{order:456}:items\"\n\"{order:456}:status\"\n</code></pre> <p>Avoid Hot Spots</p> <p>Don't use overly broad hash tags like <code>{app}:user:123</code> which puts all users on one slot.</p>"},{"location":"user-guide/compression/","title":"Compression","text":"<p>django-cachex supports pluggable compression to reduce memory usage. Compression is only applied to values larger than 256 bytes by default.</p>"},{"location":"user-guide/compression/#configuration","title":"Configuration","text":"<pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",\n        \"LOCATION\": \"valkey://127.0.0.1:6379/1\",\n        \"OPTIONS\": {\n            \"compressor\": \"django_cachex.compressors.zstd.ZStdCompressor\",\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/compression/#available-compressors","title":"Available Compressors","text":"Compressor Speed Ratio Dependency <code>django_cachex.compressors.zlib.ZlibCompressor</code> Medium Good Built-in <code>django_cachex.compressors.gzip.GzipCompressor</code> Medium Good Built-in <code>django_cachex.compressors.lzma.LzmaCompressor</code> Slow Best Built-in <code>django_cachex.compressors.lz4.Lz4Compressor</code> Fast Moderate <code>django-cachex[lz4]</code> <code>django_cachex.compressors.zstd.ZStdCompressor</code> Fast Good <code>django-cachex[zstd]</code> (Python &lt; 3.14) <p>Install optional dependencies:</p> <pre><code>uv add django-cachex[lz4]   # For LZ4\nuv add django-cachex[zstd]  # For Zstandard (Python &lt; 3.14 only)\n</code></pre> <p>Zstandard uses the built-in <code>compression.zstd</code> module on Python 3.14+.</p>"},{"location":"user-guide/compression/#fallback-for-migration","title":"Fallback for Migration","text":"<p>Specify a list of compressors to safely migrate between formats. The first is used for writing, all are tried for reading:</p> <pre><code>\"OPTIONS\": {\n    \"compressor\": [\n        \"django_cachex.compressors.zstd.ZStdCompressor\",  # Write with new format\n        \"django_cachex.compressors.gzip.GzipCompressor\",  # Read old format\n    ],\n}\n</code></pre>"},{"location":"user-guide/configuration/","title":"Configuration Reference","text":"<p>Reference for all django-cachex configuration options.</p>"},{"location":"user-guide/configuration/#basic-configuration","title":"Basic Configuration","text":"<pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",  # or RedisCache\n        \"LOCATION\": \"valkey://127.0.0.1:6379/1\",\n        \"TIMEOUT\": 300,              # Default timeout in seconds\n        \"KEY_PREFIX\": \"myapp\",       # Prefix for all keys\n        \"VERSION\": 1,                # Key version number\n        \"OPTIONS\": {\n            # See options below\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#backend-classes","title":"Backend Classes","text":"Backend Description <code>ValkeyCache</code> Standard Valkey connection <code>RedisCache</code> Standard Redis connection <code>ValkeySentinelCache</code> Valkey Sentinel high availability <code>RedisSentinelCache</code> Redis Sentinel high availability <code>ValkeyClusterCache</code> Valkey Cluster sharding <code>RedisClusterCache</code> Redis Cluster sharding <p>All backends are in <code>django_cachex.cache</code>.</p> <p>Valkey and Redis Compatibility</p> <p>Valkey and Redis are likely still fully compatible, so either backend works with either server. Valkey is recommended as it remains fully open source.</p>"},{"location":"user-guide/configuration/#location","title":"LOCATION","text":"<p>Server URL(s):</p> <pre><code># Single server (Valkey)\n\"LOCATION\": \"valkey://127.0.0.1:6379/1\"\n\n# Single server (Redis)\n\"LOCATION\": \"redis://127.0.0.1:6379/1\"\n\n# With authentication\n\"LOCATION\": \"valkey://user:password@127.0.0.1:6379/1\"\n\n# SSL/TLS\n\"LOCATION\": \"valkeys://127.0.0.1:6379/1\"  # or rediss://\n\n# Unix socket\n\"LOCATION\": \"unix:///path/to/socket?db=1\"\n\n# Multiple servers (read replicas)\n\"LOCATION\": [\n    \"valkey://127.0.0.1:6379/1\",  # Primary (writes)\n    \"valkey://127.0.0.1:6380/1\",  # Replica (reads)\n]\n\n# Or comma/semicolon separated\n\"LOCATION\": \"valkey://127.0.0.1:6379/1,valkey://127.0.0.1:6380/1\"\n</code></pre>"},{"location":"user-guide/configuration/#options-reference","title":"OPTIONS Reference","text":""},{"location":"user-guide/configuration/#serialization","title":"Serialization","text":"<pre><code>\"OPTIONS\": {\n    # Single serializer (string path, class, or instance)\n    \"serializer\": \"django_cachex.serializers.pickle.PickleSerializer\",\n\n    # Or with fallback for migration\n    \"serializer\": [\n        \"django_cachex.serializers.msgpack.MessagePackSerializer\",  # Write\n        \"django_cachex.serializers.pickle.PickleSerializer\",    # Fallback read\n    ],\n}\n</code></pre> <p>Available serializers:</p> Serializer Description <code>django_cachex.serializers.pickle.PickleSerializer</code> Python pickle (default) <code>django_cachex.serializers.json.JSONSerializer</code> JSON <code>django_cachex.serializers.msgpack.MessagePackSerializer</code> MessagePack (requires msgpack)"},{"location":"user-guide/configuration/#compression","title":"Compression","text":"<pre><code>\"OPTIONS\": {\n    # Single compressor\n    \"compressor\": \"django_cachex.compressors.zstd.ZStdCompressor\",\n\n    # Or with fallback for migration\n    \"compressor\": [\n        \"django_cachex.compressors.zstd.ZStdCompressor\",  # Write\n        \"django_cachex.compressors.zlib.ZlibCompressor\",  # Fallback read\n    ],\n}\n</code></pre> <p>Available compressors:</p> Compressor Description <code>django_cachex.compressors.zlib.ZlibCompressor</code> zlib compression <code>django_cachex.compressors.gzip.GzipCompressor</code> gzip compression <code>django_cachex.compressors.lz4.Lz4Compressor</code> LZ4 (requires lz4) <code>django_cachex.compressors.lzma.LzmaCompressor</code> LZMA <code>django_cachex.compressors.zstd.ZStdCompressor</code> Zstandard (requires zstd) <p>Compression is only applied to values larger than <code>min_length</code> bytes (default: 256).</p>"},{"location":"user-guide/configuration/#connection-pool","title":"Connection Pool","text":"<pre><code>\"OPTIONS\": {\n    # Custom pool class (use valkey.ConnectionPool for Valkey)\n    \"pool_class\": \"valkey.ConnectionPool\",\n\n    # Pool size and options (passed to pool constructor)\n    \"max_connections\": 100,\n    \"retry_on_timeout\": True,\n\n    # Socket timeouts\n    \"socket_connect_timeout\": 5,\n    \"socket_timeout\": 5,\n}\n</code></pre>"},{"location":"user-guide/configuration/#parser","title":"Parser","text":"<pre><code>\"OPTIONS\": {\n    # For Valkey with libvalkey\n    \"parser_class\": \"valkey.connection.LibvalkeyParser\",\n    # For Redis with hiredis\n    # \"parser_class\": \"redis.connection.HiredisParser\",\n}\n</code></pre>"},{"location":"user-guide/configuration/#exception-handling","title":"Exception Handling","text":"<pre><code>\"OPTIONS\": {\n    # Ignore connection errors (return default/None instead)\n    \"ignore_exceptions\": True,\n\n    # Log ignored exceptions\n    \"log_ignored_exceptions\": True,\n}\n</code></pre>"},{"location":"user-guide/configuration/#authentication","title":"Authentication","text":""},{"location":"user-guide/configuration/#password-in-url","title":"Password in URL","text":"<pre><code>\"LOCATION\": \"valkey://user:password@127.0.0.1:6379/1\"\n</code></pre>"},{"location":"user-guide/configuration/#password-with-special-characters","title":"Password with Special Characters","text":"<p>For passwords with special characters, pass via OPTIONS:</p> <pre><code>\"LOCATION\": \"valkey://127.0.0.1:6379/1\",\n\"OPTIONS\": {\n    \"password\": \"my$pecial!password\",\n}\n</code></pre>"},{"location":"user-guide/configuration/#valkeyredis-acls","title":"Valkey/Redis ACLs","text":"<pre><code>\"LOCATION\": \"valkey://username@127.0.0.1:6379/1\",\n\"OPTIONS\": {\n    \"password\": \"password\",\n}\n</code></pre>"},{"location":"user-guide/configuration/#ssltls","title":"SSL/TLS","text":""},{"location":"user-guide/configuration/#basic-ssl","title":"Basic SSL","text":"<pre><code>\"LOCATION\": \"valkeys://127.0.0.1:6379/1\"  # or rediss://\n</code></pre>"},{"location":"user-guide/configuration/#self-signed-certificates","title":"Self-Signed Certificates","text":"<pre><code>\"LOCATION\": \"valkeys://127.0.0.1:6379/1\",\n\"OPTIONS\": {\n    \"ssl_cert_reqs\": None,  # Disable verification\n}\n</code></pre>"},{"location":"user-guide/configuration/#custom-certificates","title":"Custom Certificates","text":"<pre><code>\"LOCATION\": \"valkeys://127.0.0.1:6379/1\",\n\"OPTIONS\": {\n    \"ssl_ca_certs\": \"/path/to/ca.crt\",\n    \"ssl_certfile\": \"/path/to/client.crt\",\n    \"ssl_keyfile\": \"/path/to/client.key\",\n}\n</code></pre>"},{"location":"user-guide/configuration/#sentinel-configuration","title":"Sentinel Configuration","text":"<pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.client.RedisSentinelCache\",\n        \"LOCATION\": \"redis://mymaster/0\",  # Master name\n        \"OPTIONS\": {\n            \"sentinels\": [\n                (\"sentinel1.example.com\", 26379),\n                (\"sentinel2.example.com\", 26379),\n                (\"sentinel3.example.com\", 26379),\n            ],\n            \"sentinel_kwargs\": {\n                \"password\": \"sentinel-password\",\n            },\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#cluster-configuration","title":"Cluster Configuration","text":"<pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.client.RedisClusterCache\",\n        \"LOCATION\": \"redis://127.0.0.1:7000\",\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#timeouts","title":"Timeouts","text":""},{"location":"user-guide/configuration/#default-timeout","title":"Default Timeout","text":"<pre><code>\"TIMEOUT\": 300  # 5 minutes, None for no expiry\n</code></pre>"},{"location":"user-guide/configuration/#special-values","title":"Special Values","text":"<pre><code>cache.set(\"key\", \"value\", timeout=0)     # Delete immediately\ncache.set(\"key\", \"value\", timeout=None)  # Never expires\n</code></pre>"},{"location":"user-guide/configuration/#key-configuration","title":"Key Configuration","text":""},{"location":"user-guide/configuration/#key-prefix","title":"Key Prefix","text":"<pre><code>\"KEY_PREFIX\": \"myapp\"\n# Keys become: myapp:1:keyname\n</code></pre>"},{"location":"user-guide/configuration/#key-version","title":"Key Version","text":"<pre><code>\"VERSION\": 1\n# Keys become: prefix:1:keyname\n</code></pre>"},{"location":"user-guide/configuration/#custom-key-function","title":"Custom Key Function","text":"<pre><code>def my_key_func(key, key_prefix, version):\n    return f\"{key_prefix}:v{version}:{key}\"\n\nCACHES = {\n    \"default\": {\n        ...\n        \"KEY_FUNCTION\": \"myapp.cache.my_key_func\",\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#complete-example","title":"Complete Example","text":"<pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",\n        \"LOCATION\": \"valkey://127.0.0.1:6379/1\",\n        \"TIMEOUT\": 300,\n        \"KEY_PREFIX\": \"myapp\",\n        \"VERSION\": 1,\n        \"OPTIONS\": {\n            # Serialization\n            \"serializer\": \"django_cachex.serializers.pickle.PickleSerializer\",\n\n            # Compression\n            \"compressor\": \"django_cachex.compressors.zstd.ZStdCompressor\",\n\n            # Connection pool\n            \"max_connections\": 50,\n            \"socket_connect_timeout\": 5,\n            \"socket_timeout\": 5,\n\n            # Exception handling\n            \"ignore_exceptions\": False,\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/sentinel/","title":"Valkey/Redis Sentinel","text":"<p>For basic sentinel setup, see Configuration.</p>"},{"location":"user-guide/sentinel/#configuration-options","title":"Configuration Options","text":"Option Description <code>sentinels</code> List of (host, port) tuples for Sentinel nodes (required) <code>sentinel_kwargs</code> Dict of kwargs passed to Sentinel connection (e.g., password) <p>The <code>LOCATION</code> URL format is <code>redis://service_name/db</code> (or <code>valkey://service_name/db</code> for ValkeySentinelCache) where <code>service_name</code> is the master name configured in Sentinel.</p>"},{"location":"user-guide/sentinel/#how-it-works","title":"How It Works","text":"<p>The Sentinel backend automatically:</p> <ol> <li>Connects to Sentinel nodes to discover the current primary</li> <li>Creates separate connection pools for primary (writes) and replica (reads)</li> <li>Handles failover automatically when the primary changes</li> </ol>"},{"location":"user-guide/serializers/","title":"Serializers","text":"<p>django-cachex supports pluggable serializers for data before sending to Valkey/Redis.</p>"},{"location":"user-guide/serializers/#configuration","title":"Configuration","text":"<pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",\n        \"LOCATION\": \"valkey://127.0.0.1:6379/1\",\n        \"OPTIONS\": {\n            \"serializer\": \"django_cachex.serializers.json.JSONSerializer\",\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/serializers/#available-serializers","title":"Available Serializers","text":"Serializer Description <code>django_cachex.serializers.pickle.PickleSerializer</code> Python pickle (default) - supports all Python types <code>django_cachex.serializers.json.JSONSerializer</code> JSON - interoperable but limited to JSON types <code>django_cachex.serializers.msgpack.MessagePackSerializer</code> MessagePack - fast and compact binary format <p>MessagePack requires the optional dependency:</p> <pre><code>uv add django-cachex[msgpack]\n</code></pre>"},{"location":"user-guide/serializers/#fallback-for-migration","title":"Fallback for Migration","text":"<p>Specify a list of serializers to safely migrate between formats. The first is used for writing, all are tried for reading:</p> <pre><code>\"OPTIONS\": {\n    \"serializer\": [\n        \"django_cachex.serializers.json.JSONSerializer\",     # Write with new format\n        \"django_cachex.serializers.pickle.PickleSerializer\", # Read old format\n    ],\n}\n</code></pre>"},{"location":"user-guide/serializers/#custom-serializers","title":"Custom Serializers","text":"<p>Implement <code>dumps</code> and <code>loads</code> methods, raising <code>SerializerError</code> on failure:</p> <pre><code>from django_cachex.serializers.base import BaseSerializer\nfrom django_cachex.exceptions import SerializerError\n\nclass MySerializer(BaseSerializer):\n    def dumps(self, value):\n        return my_encode(value)\n\n    def loads(self, value):\n        try:\n            return my_decode(value)\n        except MyDecodeError as e:\n            raise SerializerError from e\n</code></pre>"}]}