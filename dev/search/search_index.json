{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"django-cachex","text":"<p>Full featured Valkey and Redis cache backend for Django.</p> <p> </p>"},{"location":"#why-django-cachex","title":"Why django-cachex?","text":"<p>Drop-in replacement for Django's built-in Redis cache backend (<code>django.core.cache.backends.redis</code>) with extended features:</p> <ul> <li>Uses native valkey-py/redis-py</li> <li>Extended functionality of all typical commands for hashes, sets, lists, sorted sets, and streams</li> <li>Pluggable serializers</li> <li>Pluggable compressors</li> <li>Valkey/Redis Sentinel and Cluster support</li> <li>Primary/replica support</li> <li>Comprehensive test suite</li> <li>Facilities for raw access to Valkey/Redis client/connection pool</li> <li>Highly configurable</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.12+</li> <li>Django 5.2+</li> <li>valkey-py 6.0+ or redis-py 6.0+</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Install with pip:</p> <pre><code>pip install django-cachex\n</code></pre> <p>Configure as cache backend:</p> <pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\", # or django_cachex.cache.RedisCache\n        \"LOCATION\": \"valkey://127.0.0.1:6379/1\", # or redis://127.0.0.1:6379/1\n    }\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>MIT License. See LICENSE for details.</p>"},{"location":"migration/","title":"Migration Guide","text":""},{"location":"migration/#from-djangos-built-in-cache-backend","title":"From Django's Built-in Cache Backend","text":"<pre><code># Before (Django's Redis backend)\n\"BACKEND\": \"django.core.cache.backends.redis.RedisCache\"\n\n# After (Valkey)\n\"BACKEND\": \"django_cachex.cache.ValkeyCache\"\n\n# Or (Redis)\n\"BACKEND\": \"django_cachex.cache.RedisCache\"\n</code></pre> <p>All Django options work unchanged. You gain extended features (data structures, TTL ops, locking, compression, unified Valkey/Redis support).</p>"},{"location":"migration/#from-django-valkey","title":"From django-valkey","text":"<pre><code># Before\n\"BACKEND\": \"django_valkey.cache.ValkeyCache\"\n\"OPTIONS\": {\"CLIENT_CLASS\": \"django_valkey.client.DefaultClient\"}\n\n# After\n\"BACKEND\": \"django_cachex.cache.ValkeyCache\"\n</code></pre> <p>Key changes:</p> django-valkey django-cachex <code>CLIENT_CLASS</code> Removed - use specific backend class <code>SERIALIZER</code> <code>serializer</code> (lowercase) <code>COMPRESSOR</code> <code>compressor</code> (lowercase) <code>CONNECTION_POOL_CLASS</code> <code>pool_class</code> <code>get_valkey_connection()</code> <code>cache.get_client()</code> <p>Import paths: <code>django_valkey.*</code> \u2192 <code>django_cachex.*</code></p> <p>For Sentinel: Use <code>django_cachex.cache.ValkeySentinelCache</code> instead of <code>CLIENT_CLASS</code>.</p> <p>ValkeySentinelCache</p> <p><code>ValkeySentinelCache</code> is currently unavailable due to an upstream bug in valkey-py. Use <code>RedisSentinelCache</code> with your Valkey server instead (protocol compatible).</p>"},{"location":"migration/#from-django-redis","title":"From django-redis","text":"<pre><code># Before\n\"BACKEND\": \"django_redis.cache.RedisCache\"\n\"OPTIONS\": {\"CLIENT_CLASS\": \"django_redis.client.DefaultClient\"}\n\n# After\n\"BACKEND\": \"django_cachex.cache.RedisCache\"\n</code></pre> <p>Key changes:</p> django-redis django-cachex <code>CLIENT_CLASS</code> Removed - use specific backend class <code>SERIALIZER</code> <code>serializer</code> (lowercase) <code>COMPRESSOR</code> <code>compressor</code> (lowercase) <code>CONNECTION_POOL_CLASS</code> <code>pool_class</code> <code>get_redis_connection()</code> <code>cache.get_client()</code> <p>Import paths: <code>django_redis.*</code> \u2192 <code>django_cachex.*</code></p> <p>For Sentinel: Use <code>django_cachex.cache.RedisSentinelCache</code> instead of <code>CLIENT_CLASS</code>.</p>"},{"location":"migration/#new-features","title":"New Features","text":"<p>After migrating, you gain:</p> <ul> <li>Unified Valkey + Redis support in one package</li> <li>Multi-serializer/compressor fallback for safe migrations</li> <li>Extended data structures (hashes, lists, sets, sorted sets) directly on cache</li> <li>TTL operations (<code>ttl()</code>, <code>pttl()</code>, <code>expire()</code>, <code>persist()</code>)</li> <li>Pattern operations (<code>keys()</code>, <code>iter_keys()</code>, <code>delete_pattern()</code>)</li> <li>Distributed locking (<code>cache.lock()</code>)</li> <li>Pipelines (<code>cache.pipeline()</code>)</li> </ul>"},{"location":"recipes/","title":"Recipes","text":"<p>Practical solutions for common caching scenarios.</p>"},{"location":"recipes/#session-storage","title":"Session Storage","text":"<p>Use Valkey/Redis for Django sessions:</p> <pre><code># settings.py\nSESSION_ENGINE = \"django.contrib.sessions.backends.cache\"\nSESSION_CACHE_ALIAS = \"default\"\n\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",\n        \"LOCATION\": \"valkey://127.0.0.1:6379/0\",\n    }\n}\n</code></pre> <p>For dedicated session storage with longer TTL:</p> <pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",\n        \"LOCATION\": \"valkey://127.0.0.1:6379/0\",\n    },\n    \"sessions\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",\n        \"LOCATION\": \"valkey://127.0.0.1:6379/1\",\n        \"TIMEOUT\": 86400 * 14,  # 2 weeks\n    },\n}\n\nSESSION_CACHE_ALIAS = \"sessions\"\n</code></pre>"},{"location":"recipes/#rate-limiting","title":"Rate Limiting","text":"<p>Simple rate limiter using sorted sets:</p> <pre><code>import time\nfrom django.core.cache import cache\n\ndef is_rate_limited(user_id: str, limit: int = 100, window: int = 60) -&gt; bool:\n    \"\"\"Check if user has exceeded rate limit.\n\n    Args:\n        user_id: Unique identifier for the user\n        limit: Maximum requests allowed in window\n        window: Time window in seconds\n\n    Returns:\n        True if rate limited, False otherwise\n    \"\"\"\n    key = f\"ratelimit:{user_id}\"\n    now = time.time()\n    window_start = now - window\n\n    with cache.client.get_client(write=True) as client:\n        pipe = client.pipeline()\n        # Remove old entries\n        pipe.zremrangebyscore(key, 0, window_start)\n        # Add current request\n        pipe.zadd(key, {str(now): now})\n        # Count requests in window\n        pipe.zcard(key)\n        # Set expiry\n        pipe.expire(key, window)\n        results = pipe.execute()\n\n    count = results[2]\n    return count &gt; limit\n</code></pre>"},{"location":"recipes/#cache-invalidation-patterns","title":"Cache Invalidation Patterns","text":""},{"location":"recipes/#pattern-based-deletion","title":"Pattern-based deletion","text":"<p>Delete all keys matching a pattern:</p> <pre><code>from django.core.cache import cache\n\n# Delete all user-related cache entries\ncache.delete_pattern(\"user:*\")\n\n# Delete all cached API responses\ncache.delete_pattern(\"api:*:response\")\n</code></pre>"},{"location":"recipes/#versioned-cache-keys","title":"Versioned cache keys","text":"<p>Invalidate entire cache groups by incrementing version:</p> <pre><code>from django.core.cache import cache\n\ndef get_user_cache_version(user_id: int) -&gt; int:\n    \"\"\"Get current cache version for a user.\"\"\"\n    return cache.get(f\"user:{user_id}:version\", 1)\n\ndef invalidate_user_cache(user_id: int) -&gt; None:\n    \"\"\"Invalidate all cached data for a user.\"\"\"\n    cache.incr(f\"user:{user_id}:version\")\n\ndef get_user_data(user_id: int) -&gt; dict:\n    \"\"\"Get user data with versioned caching.\"\"\"\n    version = get_user_cache_version(user_id)\n    key = f\"user:{user_id}:data:v{version}\"\n\n    data = cache.get(key)\n    if data is None:\n        data = fetch_user_data_from_db(user_id)\n        cache.set(key, data, timeout=3600)\n    return data\n</code></pre>"},{"location":"recipes/#distributed-locking","title":"Distributed Locking","text":"<p>Prevent concurrent execution of critical sections:</p> <pre><code>from django.core.cache import cache\n\nwith cache.lock(\"process-payments\", timeout=30):\n    process_pending_payments()\n</code></pre>"},{"location":"recipes/#development-without-a-server","title":"Development Without a Server","text":"<p>For simple local development without running a server, fakeredis provides an in-memory implementation:</p> <pre><code># settings_dev.py\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.RedisCache\",\n        \"LOCATION\": \"redis://localhost:6379/0\",\n        \"OPTIONS\": {\n            \"pool_class\": \"fakeredis.FakeConnectionPool\",\n        },\n    }\n}\n</code></pre> <p>For testing</p> <p>django-cachex uses testcontainers for its test suite. Consider using the same approach for accurate behavior in your tests.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12+</li> <li>Django 5.2+</li> <li>valkey-py 6+ or redis-py 6+</li> <li>Valkey server 7+ or Redis server 6+</li> </ul>"},{"location":"getting-started/installation/#install-with-uv","title":"Install with uv","text":"<pre><code>uv add django-cachex\n</code></pre>"},{"location":"getting-started/installation/#install-with-libvalkeyhiredis-recommended","title":"Install with libvalkey/hiredis (recommended)","text":"<p>For better performance, install with the libvalkey (for Valkey) or hiredis (for Redis) parser:</p> <pre><code># For Valkey\nuv add django-cachex[libvalkey]\n\n# For Redis\nuv add django-cachex[hiredis]\n</code></pre> <p>These packages provide C-based parsers that can significantly improve performance when parsing replies.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":""},{"location":"getting-started/quickstart/#configure-as-cache-backend","title":"Configure as Cache Backend","text":"<pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",\n        \"LOCATION\": \"valkey://127.0.0.1:6379/1\",\n    }\n}\n</code></pre>"},{"location":"getting-started/quickstart/#backend-classes","title":"Backend Classes","text":"Backend Description <code>ValkeyCache</code> Standard Valkey connection <code>RedisCache</code> Standard Redis connection <code>ValkeySentinelCache</code> Valkey Sentinel high availability <code>RedisSentinelCache</code> Redis Sentinel high availability <code>RedisClusterCache</code> Redis Cluster sharding <p>Valkey and Redis Compatibility</p> <p>Valkey and Redis are fully compatible - you can use either backend with either server. We recommend Valkey as it remains fully open source.</p> <p>ValkeyClusterCache</p> <p><code>ValkeyClusterCache</code> is currently unavailable due to an upstream bug in valkey-py. Use <code>RedisClusterCache</code> with your Valkey cluster instead.</p>"},{"location":"getting-started/quickstart/#connection-url-formats","title":"Connection URL Formats","text":"<p>django-cachex uses the valkey-py/redis-py native URL notation for connection strings:</p> <ul> <li><code>valkey://[[username]:[password]]@localhost:6379/0</code> - Valkey TCP connection</li> <li><code>redis://[[username]:[password]]@localhost:6379/0</code> - Redis TCP connection</li> <li><code>valkeys://[[username]:[password]]@localhost:6379/0</code> - Valkey SSL/TLS connection</li> <li><code>rediss://[[username]:[password]]@localhost:6379/0</code> - Redis SSL/TLS connection</li> <li><code>unix://[[username]:[password]]@/path/to/socket.sock?db=0</code> - Unix socket</li> </ul>"},{"location":"getting-started/quickstart/#database-selection","title":"Database Selection","text":"<p>There are two ways to specify the database number:</p> <ol> <li>Query string: <code>valkey://localhost?db=0</code></li> <li>Path (for <code>valkey://</code> or <code>redis://</code> scheme): <code>valkey://localhost/0</code></li> </ol>"},{"location":"getting-started/quickstart/#configure-as-session-backend","title":"Configure as Session Backend","text":"<p>Django can use any cache backend as session storage:</p> <pre><code>SESSION_ENGINE = \"django.contrib.sessions.backends.cache\"\nSESSION_CACHE_ALIAS = \"default\"\n</code></pre>"},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":"<pre><code>from django.core.cache import cache\n\n# Standard Django cache methods\ncache.set(\"key\", \"value\", timeout=300)\nvalue = cache.get(\"key\")\n\n# Extended data structure methods\ncache.hset(\"user:1\", \"name\", \"Alice\")\ncache.zrange(\"leaderboard\", 0, 10)\n\n# Async versions\nawait cache.aget(\"key\")\nawait cache.ahset(\"user:1\", \"name\", \"Alice\")\n</code></pre>"},{"location":"getting-started/quickstart/#raw-client-access","title":"Raw Client Access","text":"<p>For operations not exposed by the cache interface:</p> <pre><code>client = cache.get_client()\nclient.publish(\"channel\", \"message\")\n</code></pre>"},{"location":"reference/api/","title":"API Reference","text":""},{"location":"reference/api/#cache-methods","title":"Cache Methods","text":""},{"location":"reference/api/#standard-django-cache-methods","title":"Standard Django Cache Methods","text":"<p>All standard Django cache methods are supported:</p> Method Description <code>get(key, default=None)</code> Get a value <code>set(key, value, timeout=DEFAULT)</code> Set a value <code>delete(key)</code> Delete a key <code>get_many(keys)</code> Get multiple values <code>set_many(mapping, timeout=DEFAULT)</code> Set multiple values <code>delete_many(keys)</code> Delete multiple keys <code>clear()</code> Clear the cache <code>has_key(key)</code> Check if key exists <code>incr(key, delta=1)</code> Increment a value <code>decr(key, delta=1)</code> Decrement a value <code>close()</code> Close connections"},{"location":"reference/api/#extended-methods","title":"Extended Methods","text":"<p>django-cachex adds these extended methods:</p> Method Description <code>ttl(key)</code> Get TTL in seconds <code>pttl(key)</code> Get TTL in milliseconds <code>expire(key, timeout)</code> Set expiration in seconds <code>pexpire(key, timeout)</code> Set expiration in milliseconds <code>expire_at(key, when)</code> Set expiration at datetime <code>pexpire_at(key, when)</code> Set expiration at datetime (ms precision) <code>persist(key)</code> Remove expiration <code>lock(key, ...)</code> Get a distributed lock <code>keys(pattern)</code> Get keys matching pattern <code>iter_keys(pattern)</code> Iterate keys matching pattern <code>delete_pattern(pattern)</code> Delete keys matching pattern"},{"location":"reference/api/#hash-methods","title":"Hash Methods","text":"<p>Hash operations for field-value data structures:</p> Method Description <code>hset(key, field, value)</code> Set a hash field value <code>hdel(key, *fields)</code> Delete hash field(s) <code>hexists(key, field)</code> Check if hash field exists <code>hget(key, field)</code> Get a hash field value <code>hgetall(key)</code> Get all fields and values in a hash <code>hincrby(key, field, amount=1)</code> Increment hash field by integer <code>hincrbyfloat(key, field, amount=1.0)</code> Increment hash field by float <code>hlen(key)</code> Get number of fields in hash <code>hmget(key, *fields)</code> Get multiple hash field values <code>hmset(key, mapping)</code> Set multiple hash fields <code>hsetnx(key, field, value)</code> Set hash field only if it doesn't exist <code>hvals(key)</code> Get all values in a hash"},{"location":"reference/api/#sorted-set-methods","title":"Sorted Set Methods","text":"<p>Sorted set operations for scored, ordered collections:</p> Method Description <code>zadd(key, *args, **kwargs)</code> Add member(s) with scores <code>zcard(key)</code> Get number of members <code>zcount(key, min, max)</code> Count members with scores in range <code>zincrby(key, amount, member)</code> Increment member's score <code>zrange(key, start, end, ...)</code> Get members by index range <code>zrangebyscore(key, min, max, ...)</code> Get members by score range <code>zrank(key, member)</code> Get member's rank (ascending) <code>zrevrank(key, member)</code> Get member's rank (descending) <code>zrem(key, *members)</code> Remove member(s) <code>zremrangebyrank(key, start, end)</code> Remove members by rank range <code>zscore(key, member)</code> Get member's score <code>zmscore(key, *members)</code> Get multiple members' scores"},{"location":"reference/api/#list-methods","title":"List Methods","text":"<p>List operations for ordered, indexable collections:</p> Method Description <code>llen(key)</code> Get list length <code>lpush(key, *values)</code> Prepend value(s) to list <code>rpush(key, *values)</code> Append value(s) to list <code>lpop(key)</code> Remove and return first element <code>rpop(key)</code> Remove and return last element <code>lindex(key, index)</code> Get element by index <code>lrange(key, start, end)</code> Get elements in range <code>lset(key, index, value)</code> Set element at index <code>ltrim(key, start, end)</code> Trim list to range <code>lpos(key, element, ...)</code> Find element position in list <code>lmove(src, dst, src_side, dst_side)</code> Atomically move element between lists"},{"location":"reference/api/#set-method-options","title":"Set Method Options","text":"<pre><code>cache.set(key, value, timeout=300, nx=False, xx=False)\n</code></pre> Parameter Description <code>timeout</code> Expiration in seconds (<code>None</code> = never, <code>0</code> = immediate) <code>nx</code> Only set if key doesn't exist (SETNX) <code>xx</code> Only set if key exists"},{"location":"reference/api/#raw-client-access","title":"Raw Client Access","text":"<pre><code>client = cache.get_client(write=True)\n</code></pre> Parameter Description <code>write</code> Get write connection for primary (default: <code>True</code>) <p>Returns the underlying <code>valkey.Valkey</code> or <code>redis.Redis</code> client instance.</p>"},{"location":"reference/api/#lock-interface","title":"Lock Interface","text":"<pre><code>lock = cache.lock(key, timeout=None, sleep=0.1, blocking=True, blocking_timeout=None)\n</code></pre> Parameter Description <code>key</code> Lock name <code>timeout</code> Lock auto-release timeout <code>sleep</code> Time between acquire attempts <code>blocking</code> Wait for lock if held <code>blocking_timeout</code> Max wait time for lock <p>Compatible with <code>threading.Lock</code>:</p> <pre><code># Context manager\nwith cache.lock(\"mylock\"):\n    do_work()\n\n# Manual acquire/release\nlock = cache.lock(\"mylock\")\nif lock.acquire():\n    try:\n        do_work()\n    finally:\n        lock.release()\n</code></pre>"},{"location":"reference/api/#settings-reference","title":"Settings Reference","text":""},{"location":"reference/api/#cache-options","title":"Cache OPTIONS","text":"Option Description <code>serializer</code> Serializer class or list for fallback <code>compressor</code> Compressor class or list for fallback <code>password</code> Server password <code>socket_connect_timeout</code> Connection timeout <code>socket_timeout</code> Read/write timeout <code>ignore_exceptions</code> Ignore connection errors <code>log_ignored_exceptions</code> Log ignored exceptions <code>pool_class</code> Custom connection pool class <code>max_connections</code> Maximum pool connections <code>sentinels</code> Sentinel server list (for Sentinel backends) <code>sentinel_kwargs</code> Sentinel configuration"},{"location":"reference/changelog/","title":"Changelog","text":""},{"location":"reference/changelog/#010-january-2026","title":"0.1.0 (January 2026)","text":"<p>Initial release of django-cachex.</p>"},{"location":"reference/changelog/#features","title":"Features","text":"<ul> <li>Unified Valkey + Redis support in one package</li> <li>Full-featured cache backend for Django</li> <li>Session backend support via Django's cache sessions</li> <li>Pluggable clients (Default, Sentinel, Cluster)</li> <li>Pluggable serializers (Pickle, JSON, MsgPack)</li> <li>Pluggable compressors (Zlib, Gzip, LZMA, LZ4, Zstandard)</li> <li>Multi-serializer/compressor fallback for safe migrations</li> <li>Connection pooling with configurable options</li> <li>Primary/replica replication support</li> <li>Valkey/Redis Sentinel support for high availability</li> <li>Valkey/Redis Cluster support with automatic slot handling</li> <li>Distributed locks compatible with <code>threading.Lock</code></li> <li>TTL operations (<code>ttl()</code>, <code>pttl()</code>, <code>expire()</code>, <code>persist()</code>)</li> <li>Pattern operations (<code>keys()</code>, <code>iter_keys()</code>, <code>delete_pattern()</code>)</li> <li>Pipelines for batched operations</li> </ul>"},{"location":"reference/changelog/#data-structure-operations","title":"Data Structure Operations","text":"<ul> <li>Hash operations: <code>hset</code>, <code>hdel</code>, <code>hexists</code>, <code>hget</code>, <code>hgetall</code>, <code>hincrby</code>, <code>hincrbyfloat</code>, <code>hlen</code>, <code>hmget</code>, <code>hmset</code>, <code>hsetnx</code>, <code>hvals</code></li> <li>Sorted set operations: <code>zadd</code>, <code>zcard</code>, <code>zcount</code>, <code>zincrby</code>, <code>zrange</code>, <code>zrangebyscore</code>, <code>zrank</code>, <code>zrevrank</code>, <code>zrem</code>, <code>zremrangebyrank</code>, <code>zscore</code>, <code>zmscore</code></li> <li>List operations: <code>llen</code>, <code>lpush</code>, <code>rpush</code>, <code>lpop</code>, <code>rpop</code>, <code>lindex</code>, <code>lrange</code>, <code>lset</code>, <code>ltrim</code>, <code>lpos</code>, <code>lmove</code></li> </ul>"},{"location":"reference/changelog/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12+</li> <li>Django 5.2+</li> <li>valkey-py 6+ or redis-py 6+</li> </ul>"},{"location":"user-guide/advanced/","title":"Advanced Usage","text":""},{"location":"user-guide/advanced/#pickle-version","title":"Pickle Version","text":"<p>By default, django-cachex uses <code>pickle.DEFAULT_PROTOCOL</code>. To set a specific version:</p> <pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",\n        \"LOCATION\": \"valkey://127.0.0.1:6379/1\",\n        \"OPTIONS\": {\n            \"PICKLE_VERSION\": -1  # Highest protocol available\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/advanced/#ttl-operations","title":"TTL Operations","text":""},{"location":"user-guide/advanced/#get-ttl","title":"Get TTL","text":"<pre><code>from django.core.cache import cache\n\ncache.set(\"foo\", \"value\", timeout=25)\ncache.ttl(\"foo\")      # Returns 25\ncache.ttl(\"missing\")  # Returns 0 (key doesn't exist)\n</code></pre> <p>Returns:</p> <ul> <li><code>0</code> - Key doesn't exist or already expired</li> <li><code>None</code> - Key exists but has no expiration</li> <li><code>int</code> - Seconds until expiration</li> </ul>"},{"location":"user-guide/advanced/#get-ttl-in-milliseconds","title":"Get TTL in Milliseconds","text":"<pre><code>cache.set(\"foo\", \"value\", timeout=25)\ncache.pttl(\"foo\")  # Returns 25000\n</code></pre>"},{"location":"user-guide/advanced/#expire-persist","title":"Expire &amp; Persist","text":""},{"location":"user-guide/advanced/#set-expiration","title":"Set Expiration","text":"<pre><code>cache.set(\"foo\", \"bar\", timeout=22)\ncache.expire(\"foo\", timeout=5)\ncache.ttl(\"foo\")  # Returns 5\n</code></pre>"},{"location":"user-guide/advanced/#set-expiration-in-milliseconds","title":"Set Expiration in Milliseconds","text":"<pre><code>cache.set(\"foo\", \"bar\", timeout=22)\ncache.pexpire(\"foo\", timeout=5500)\ncache.pttl(\"foo\")  # Returns 5500\n</code></pre>"},{"location":"user-guide/advanced/#expire-at-specific-time","title":"Expire at Specific Time","text":"<pre><code>from datetime import datetime, timedelta\n\ncache.set(\"foo\", \"bar\", timeout=22)\ncache.expire_at(\"foo\", datetime.now() + timedelta(hours=1))\ncache.ttl(\"foo\")  # Returns ~3600\n</code></pre>"},{"location":"user-guide/advanced/#expire-at-specific-time-milliseconds-precision","title":"Expire at Specific Time (milliseconds precision)","text":"<pre><code>cache.set(\"foo\", \"bar\", timeout=22)\ncache.pexpire_at(\"foo\", datetime.now() + timedelta(milliseconds=900, hours=1))\ncache.pttl(\"foo\")  # Returns ~3600900\n</code></pre>"},{"location":"user-guide/advanced/#remove-expiration","title":"Remove Expiration","text":"<pre><code>cache.set(\"foo\", \"bar\", timeout=22)\ncache.persist(\"foo\")\ncache.ttl(\"foo\")  # Returns None (no expiration)\n</code></pre>"},{"location":"user-guide/advanced/#locks","title":"Locks","text":"<p>Distributed locks with the same interface as <code>threading.Lock</code>:</p> <pre><code>from django.core.cache import cache\n\nwith cache.lock(\"somekey\"):\n    do_some_thing()\n</code></pre>"},{"location":"user-guide/advanced/#bulk-operations","title":"Bulk Operations","text":""},{"location":"user-guide/advanced/#search-keys","title":"Search Keys","text":"<pre><code>from django.core.cache import cache\n\n# Get all matching keys (not recommended for large datasets)\ncache.keys(\"foo_*\")  # Returns [\"foo_1\", \"foo_2\"]\n</code></pre>"},{"location":"user-guide/advanced/#iterate-keys-recommended","title":"Iterate Keys (Recommended)","text":"<p>For large datasets, use server-side cursors:</p> <pre><code># Returns a generator\nfor key in cache.iter_keys(\"foo_*\"):\n    print(key)\n</code></pre>"},{"location":"user-guide/advanced/#delete-by-pattern","title":"Delete by Pattern","text":"<pre><code>cache.delete_pattern(\"foo_*\")\n</code></pre> <p>For better performance with many keys:</p> <pre><code>cache.delete_pattern(\"foo_*\", itersize=100_000)\n</code></pre>"},{"location":"user-guide/advanced/#atomic-operations","title":"Atomic Operations","text":""},{"location":"user-guide/advanced/#setnx-set-if-not-exists","title":"SETNX (Set if Not Exists)","text":"<pre><code>cache.set(\"key\", \"value1\", nx=True)  # Returns True\ncache.set(\"key\", \"value2\", nx=True)  # Returns False\ncache.get(\"key\")  # Returns \"value1\"\n</code></pre>"},{"location":"user-guide/advanced/#incrementdecrement","title":"Increment/Decrement","text":"<pre><code>cache.set(\"counter\", 0)\ncache.incr(\"counter\")  # Returns 1\ncache.incr(\"counter\", delta=5)  # Returns 6\ncache.decr(\"counter\")  # Returns 5\n</code></pre>"},{"location":"user-guide/advanced/#data-structures","title":"Data Structures","text":"<p>django-cachex provides direct access to Valkey/Redis data structures through the cache interface.</p>"},{"location":"user-guide/advanced/#hashes","title":"Hashes","text":"<p>Hashes are maps of field-value pairs, useful for storing objects:</p> <pre><code>from django.core.cache import cache\n\n# Set a single field\ncache.hset(\"user:1\", \"name\", \"Alice\")\n\n# Set multiple fields at once\ncache.hmset(\"user:1\", {\"email\": \"alice@example.com\", \"age\": 30})\n\n# Get a single field\nname = cache.hget(\"user:1\", \"name\")  # \"Alice\"\n\n# Get multiple fields\nvalues = cache.hmget(\"user:1\", \"name\", \"email\")  # [\"Alice\", \"alice@example.com\"]\n\n# Get all fields and values\nuser = cache.hgetall(\"user:1\")  # {\"name\": \"Alice\", \"email\": \"...\", \"age\": 30}\n\n# Increment a numeric field\ncache.hincrby(\"user:1\", \"age\", 1)  # 31\ncache.hincrbyfloat(\"user:1\", \"score\", 0.5)  # For floating point\n\n# Check if field exists\ncache.hexists(\"user:1\", \"name\")  # True\n\n# Delete fields\ncache.hdel(\"user:1\", \"age\")\n\n# Get count of fields\ncache.hlen(\"user:1\")  # 2\n\n# Get all values\ncache.hvals(\"user:1\")  # [\"Alice\", \"alice@example.com\"]\n</code></pre>"},{"location":"user-guide/advanced/#sorted-sets","title":"Sorted Sets","text":"<p>Sorted sets store unique members with scores, automatically sorted by score:</p> <pre><code>from django.core.cache import cache\n\n# Add members with scores\ncache.zadd(\"leaderboard\", {\"alice\": 100, \"bob\": 85, \"charlie\": 92})\n\n# Get rank (0-indexed, ascending by score)\ncache.zrank(\"leaderboard\", \"alice\")  # 2 (highest score = last)\ncache.zrevrank(\"leaderboard\", \"alice\")  # 0 (highest score = first)\n\n# Get score\ncache.zscore(\"leaderboard\", \"bob\")  # 85.0\n\n# Get multiple scores\ncache.zmscore(\"leaderboard\", \"alice\", \"bob\")  # [100.0, 85.0]\n\n# Increment score\ncache.zincrby(\"leaderboard\", 10, \"bob\")  # 95.0\n\n# Get range by rank (ascending)\ncache.zrange(\"leaderboard\", 0, -1)  # All members sorted by score\n\n# Get range by rank with scores\ncache.zrange(\"leaderboard\", 0, -1, withscores=True)\n\n# Get range by score\ncache.zrangebyscore(\"leaderboard\", 80, 100)\n\n# Count members in score range\ncache.zcount(\"leaderboard\", 80, 100)  # 3\n\n# Remove members\ncache.zrem(\"leaderboard\", \"charlie\")\n\n# Remove by rank range\ncache.zremrangebyrank(\"leaderboard\", 0, 1)  # Remove lowest 2\n\n# Get total count\ncache.zcard(\"leaderboard\")\n</code></pre>"},{"location":"user-guide/advanced/#lists","title":"Lists","text":"<p>Lists are ordered collections of elements:</p> <pre><code>from django.core.cache import cache\n\n# Push elements\ncache.lpush(\"queue\", \"first\")  # Prepend (left)\ncache.rpush(\"queue\", \"last\")   # Append (right)\n\n# Pop elements\ncache.lpop(\"queue\")  # Remove and return first\ncache.rpop(\"queue\")  # Remove and return last\n\n# Get element by index\ncache.lindex(\"queue\", 0)  # First element\n\n# Get range of elements\ncache.lrange(\"queue\", 0, -1)  # All elements\n\n# Set element at index\ncache.lset(\"queue\", 0, \"new_first\")\n\n# Trim to range\ncache.ltrim(\"queue\", 0, 99)  # Keep first 100 elements\n\n# Get length\ncache.llen(\"queue\")\n\n# Find element position\ncache.lpos(\"queue\", \"target\")  # Returns index or None\n\n# Move element between lists atomically\ncache.lmove(\"source\", \"dest\", \"LEFT\", \"RIGHT\")  # LPOP source, RPUSH dest\n</code></pre>"},{"location":"user-guide/advanced/#raw-client-access","title":"Raw Client Access","text":"<p>Access the underlying valkey-py/redis-py client:</p> <pre><code>client = cache.get_client()\nclient.publish(\"channel\", \"message\")\n</code></pre>"},{"location":"user-guide/async/","title":"Async Support","text":"<p>django-cachex provides full async support for all cache operations, enabling efficient use with Django's async views and ASGI servers.</p>"},{"location":"user-guide/async/#overview","title":"Overview","text":"<p>Django 4.0+ added async methods to the cache framework with the <code>a</code> prefix (e.g., <code>aget</code>, <code>aset</code>, <code>adelete</code>). django-cachex implements these using native async clients from <code>redis.asyncio</code> and <code>valkey.asyncio</code>, providing true async operations without thread pool overhead.</p> <p>A single cache backend instance supports both sync and async operations simultaneously. This mirrors Django's approach where <code>cache.get()</code> and <code>await cache.aget()</code> work on the same backend - no separate \"async backend\" configuration needed.</p>"},{"location":"user-guide/async/#basic-usage","title":"Basic Usage","text":"<pre><code>from django.core.cache import cache\n\n# Async views (ASGI)\nasync def my_view(request):\n    # Read\n    value = await cache.aget(\"key\")\n\n    # Write\n    await cache.aset(\"key\", \"value\", timeout=300)\n\n    # Delete\n    await cache.adelete(\"key\")\n\n    # Check existence\n    exists = await cache.ahas_key(\"key\")\n\n    return JsonResponse({\"value\": value})\n</code></pre>"},{"location":"user-guide/async/#available-async-methods","title":"Available Async Methods","text":""},{"location":"user-guide/async/#standard-django-cache-methods","title":"Standard Django Cache Methods","text":"<p>All standard Django cache methods have async equivalents:</p> Sync Async <code>get(key)</code> <code>aget(key)</code> <code>set(key, value, timeout)</code> <code>aset(key, value, timeout)</code> <code>add(key, value, timeout)</code> <code>aadd(key, value, timeout)</code> <code>delete(key)</code> <code>adelete(key)</code> <code>get_many(keys)</code> <code>aget_many(keys)</code> <code>set_many(mapping, timeout)</code> <code>aset_many(mapping, timeout)</code> <code>delete_many(keys)</code> <code>adelete_many(keys)</code> <code>has_key(key)</code> <code>ahas_key(key)</code> <code>incr(key, delta)</code> <code>aincr(key, delta)</code> <code>decr(key, delta)</code> <code>adecr(key, delta)</code> <code>touch(key, timeout)</code> <code>atouch(key, timeout)</code> <code>clear()</code> <code>aclear()</code> <code>close()</code> <code>aclose()</code> <code>get_or_set(key, default, timeout)</code> <code>aget_or_set(key, default, timeout)</code> <code>incr_version(key)</code> <code>aincr_version(key)</code> <code>decr_version(key)</code> <code>adecr_version(key)</code>"},{"location":"user-guide/async/#extended-methods","title":"Extended Methods","text":"<p>django-cachex extended methods also have async versions:</p> <pre><code># TTL operations\nttl = await cache.attl(\"key\")           # Get TTL in seconds\npttl = await cache.apttl(\"key\")         # Get TTL in milliseconds\nawait cache.aexpire(\"key\", timeout=60)  # Set expiration\nawait cache.apersist(\"key\")             # Remove expiration\n\n# Key operations\nkeys = await cache.akeys(\"pattern:*\")\nawait cache.adelete_pattern(\"session:*\")\nawait cache.arename(\"old_key\", \"new_key\")\n\n# Iterate keys (memory-efficient)\nasync for key in cache.aiter_keys(\"user:*\"):\n    print(key)\n</code></pre>"},{"location":"user-guide/async/#data-structures","title":"Data Structures","text":"<p>All data structure operations have async equivalents:</p> <pre><code># Hashes\nawait cache.ahset(\"user:1\", \"name\", \"Alice\")\nname = await cache.ahget(\"user:1\", \"name\")\nuser = await cache.ahgetall(\"user:1\")\n\n# Lists\nawait cache.alpush(\"queue\", \"item\")\nitem = await cache.alpop(\"queue\")\nitems = await cache.alrange(\"queue\", 0, -1)\n\n# Sets\nawait cache.asadd(\"tags\", \"python\", \"django\")\nmembers = await cache.asmembers(\"tags\")\nis_member = await cache.asismember(\"tags\", \"python\")\n\n# Sorted Sets\nawait cache.azadd(\"leaderboard\", {\"alice\": 100, \"bob\": 85})\nrank = await cache.azrank(\"leaderboard\", \"alice\")\ntop_players = await cache.azrange(\"leaderboard\", 0, 9, withscores=True)\n\n# Streams\nentry_id = await cache.axadd(\"events\", {\"type\": \"login\", \"user\": \"alice\"})\nentries = await cache.axrange(\"events\", \"-\", \"+\", count=10)\n</code></pre>"},{"location":"user-guide/async/#how-it-works","title":"How It Works","text":""},{"location":"user-guide/async/#connection-pool-architecture","title":"Connection Pool Architecture","text":"<p>django-cachex maintains separate connection pools for sync and async operations:</p> <ul> <li>Sync pools: Standard connection pools (<code>redis.ConnectionPool</code> / <code>valkey.ConnectionPool</code>), one per server</li> <li>Async pools: Async connection pools (<code>redis.asyncio.ConnectionPool</code> / <code>valkey.asyncio.ConnectionPool</code>), cached per event loop</li> </ul> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Cache Backend                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Sync Pools                 \u2502  Async Pools              \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500               \u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500             \u2502\n\u2502  pools[0] \u2192 server1         \u2502  loop1 \u2192 {0: pool, ...}   \u2502\n\u2502  pools[1] \u2192 server2         \u2502  loop2 \u2192 {0: pool, ...}   \u2502\n\u2502  ...                        \u2502  ...                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"user-guide/async/#per-event-loop-caching","title":"Per-Event-Loop Caching","text":"<p>Async pools are stored in a <code>WeakKeyDictionary</code> keyed by event loop. This provides:</p> <ol> <li>Automatic cleanup: When an event loop is garbage collected, its pools are automatically cleaned up</li> <li>Thread safety: Each event loop gets its own set of pools</li> <li>Connection reuse: Within the same event loop, connections are efficiently reused</li> </ol>"},{"location":"user-guide/async/#performance-considerations","title":"Performance Considerations","text":"<p>Event Loop Lifecycle</p> <p>Async pool connections are cached per event loop. This works efficiently for long-lived event loops but has implications for short-lived ones.</p>"},{"location":"user-guide/async/#efficient-long-lived-event-loops","title":"Efficient: Long-Lived Event Loops","text":"<p>ASGI servers (uvicorn, daphne, hypercorn) maintain long-lived event loops, making async operations very efficient:</p> <pre><code># In an ASGI application - efficient!\nasync def my_view(request):\n    # Connections are reused across requests\n    value = await cache.aget(\"key\")\n    await cache.aset(\"key\", \"new_value\")\n    return JsonResponse({\"value\": value})\n</code></pre>"},{"location":"user-guide/async/#inefficient-short-lived-event-loops","title":"Inefficient: Short-Lived Event Loops","text":"<p>Avoid async cache methods when event loops are frequently created and destroyed:</p> <pre><code># BAD: Each asyncio.run() creates a new event loop = new connection pool\ndef sync_function():\n    for i in range(100):\n        # Creates 100 connection pools!\n        asyncio.run(cache.aget(f\"key:{i}\"))\n\n# BAD: sync_to_async may create temporary event loops\n@sync_to_async\ndef wrapped_function():\n    # May not reuse connections efficiently\n    pass\n</code></pre>"},{"location":"user-guide/async/#recommendations","title":"Recommendations","text":"Context Recommendation ASGI views (uvicorn, daphne) Use async methods (<code>aget</code>, <code>aset</code>, etc.) WSGI views (gunicorn, uwsgi) Use sync methods (<code>get</code>, <code>set</code>, etc.) Management commands Use sync methods Celery tasks Use sync methods Background tasks with persistent loop Use async methods"},{"location":"user-guide/async/#configuration","title":"Configuration","text":""},{"location":"user-guide/async/#custom-async-pool-class","title":"Custom Async Pool Class","text":"<p>You can provide a custom async connection pool class:</p> <pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.RedisCache\",\n        \"LOCATION\": \"redis://127.0.0.1:6379/1\",\n        \"OPTIONS\": {\n            # Custom async pool class (import path or class)\n            \"async_pool_class\": \"myapp.pools.CustomAsyncConnectionPool\",\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/async/#closing-async-connections","title":"Closing Async Connections","text":"<p>To explicitly close async connections (e.g., during shutdown):</p> <pre><code>await cache.aclose()\n</code></pre> <p>This closes the async connection pool for the current event loop. The sync pools remain open.</p>"},{"location":"user-guide/async/#mixed-syncasync-usage","title":"Mixed Sync/Async Usage","text":"<p>A single cache instance works for both sync and async code:</p> <pre><code>from django.core.cache import cache\n\n# Sync code path\ndef sync_view(request):\n    value = cache.get(\"key\")           # Uses sync pool\n    cache.set(\"key\", \"value\")\n    return HttpResponse(value)\n\n# Async code path\nasync def async_view(request):\n    value = await cache.aget(\"key\")    # Uses async pool\n    await cache.aset(\"key\", \"value\")\n    return JsonResponse({\"value\": value})\n</code></pre> <p>Both views can use the same cache backend configured in settings - no separate configuration needed.</p>"},{"location":"user-guide/async/#cluster-and-sentinel","title":"Cluster and Sentinel","text":"<p>Async support is available for all backend types:</p> <pre><code># Cluster - async works the same way\nasync def cluster_example():\n    await cache.aset(\"key\", \"value\")\n    await cache.aget_many([\"key1\", \"key2\", \"key3\"])\n\n# Sentinel - async works the same way\nasync def sentinel_example():\n    await cache.aset(\"key\", \"value\")\n    value = await cache.aget(\"key\")\n</code></pre>"},{"location":"user-guide/async/#complete-example","title":"Complete Example","text":"<pre><code># settings.py\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",\n        \"LOCATION\": \"valkey://127.0.0.1:6379/1\",\n        \"TIMEOUT\": 300,\n        \"OPTIONS\": {\n            \"max_connections\": 50,\n        }\n    }\n}\n\n# views.py\nfrom django.core.cache import cache\nfrom django.http import JsonResponse\n\nasync def user_profile(request, user_id):\n    cache_key = f\"user:{user_id}:profile\"\n\n    # Try cache first\n    profile = await cache.aget(cache_key)\n\n    if profile is None:\n        # Cache miss - fetch from database\n        profile = await get_user_profile_from_db(user_id)\n        await cache.aset(cache_key, profile, timeout=3600)\n\n    return JsonResponse(profile)\n\nasync def leaderboard(request):\n    # Get top 10 from sorted set\n    top_players = await cache.azrange(\n        \"game:leaderboard\",\n        0, 9,\n        desc=True,\n        withscores=True\n    )\n\n    return JsonResponse({\"leaderboard\": top_players})\n</code></pre>"},{"location":"user-guide/cluster/","title":"Valkey/Redis Cluster","text":"<p>For basic cluster setup, see Configuration.</p>"},{"location":"user-guide/cluster/#slot-handling","title":"Slot Handling","text":"<p>Valkey/Redis Cluster distributes keys across 16384 hash slots. django-cachex handles this differently for Django cache methods vs direct commands:</p> <p>Django cache methods (<code>get_many</code>, <code>set_many</code>, <code>delete_many</code>, <code>keys</code>, <code>clear</code>) are cluster-aware and handle cross-slot operations automatically.</p> <p>Direct commands (sets, lists, hashes, sorted sets) pass through to the server. Multi-key commands (<code>sdiff</code>, <code>sinter</code>, <code>sunion</code>, <code>lmove</code>) require all keys on the same slot.</p>"},{"location":"user-guide/cluster/#hash-tags","title":"Hash Tags","text":"<p>Force keys to the same slot using hash tags - the substring between <code>{</code> and <code>}</code>:</p> <pre><code># Same slot (hash tag is \"user:123\")\ncache.sadd(\"{user:123}:followers\", \"alice\", \"bob\")\ncache.sadd(\"{user:123}:following\", \"charlie\")\n\n# Multi-key operations now work\ncache.sdiff(\"{user:123}:followers\", \"{user:123}:following\")\n</code></pre> <p>Use hash tags when you need:</p> <ul> <li>Multi-key set operations: <code>sdiff</code>, <code>sinter</code>, <code>sunion</code></li> <li>List moves: <code>lmove</code></li> <li>Transactions across multiple keys</li> </ul> <pre><code># Group related keys\n\"{user:123}:profile\"\n\"{user:123}:settings\"\n\"{order:456}:items\"\n\"{order:456}:status\"\n</code></pre> <p>Avoid Hot Spots</p> <p>Don't use overly broad hash tags like <code>{app}:user:123</code> which puts all users on one slot.</p>"},{"location":"user-guide/compression/","title":"Compression","text":"<p>django-cachex supports pluggable compression to reduce memory usage. Compression is only applied to values larger than 256 bytes by default.</p>"},{"location":"user-guide/compression/#configuration","title":"Configuration","text":"<pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",\n        \"LOCATION\": \"valkey://127.0.0.1:6379/1\",\n        \"OPTIONS\": {\n            \"compressor\": \"django_cachex.compressors.zstd.ZStdCompressor\",\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/compression/#available-compressors","title":"Available Compressors","text":"Compressor Speed Ratio Dependency <code>django_cachex.compressors.zlib.ZlibCompressor</code> Medium Good Built-in <code>django_cachex.compressors.gzip.GzipCompressor</code> Medium Good Built-in <code>django_cachex.compressors.lzma.LzmaCompressor</code> Slow Best Built-in <code>django_cachex.compressors.lz4.Lz4Compressor</code> Fast Moderate <code>django-cachex[lz4]</code> <code>django_cachex.compressors.zstd.ZStdCompressor</code> Fast Good <code>django-cachex[zstd]</code> (Python &lt; 3.14) <p>Install optional dependencies:</p> <pre><code>uv add django-cachex[lz4]   # For LZ4\nuv add django-cachex[zstd]  # For Zstandard (Python &lt; 3.14 only)\n</code></pre> <p>Zstandard uses the built-in <code>compression.zstd</code> module on Python 3.14+.</p>"},{"location":"user-guide/compression/#fallback-for-migration","title":"Fallback for Migration","text":"<p>Specify a list of compressors to safely migrate between formats. The first is used for writing, all are tried for reading:</p> <pre><code>\"OPTIONS\": {\n    \"compressor\": [\n        \"django_cachex.compressors.zstd.ZStdCompressor\",  # Write with new format\n        \"django_cachex.compressors.gzip.GzipCompressor\",  # Read old format\n    ],\n}\n</code></pre>"},{"location":"user-guide/configuration/","title":"Configuration Reference","text":"<p>Complete reference for all django-cachex configuration options.</p>"},{"location":"user-guide/configuration/#basic-configuration","title":"Basic Configuration","text":"<pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",  # or RedisCache\n        \"LOCATION\": \"valkey://127.0.0.1:6379/1\",\n        \"TIMEOUT\": 300,              # Default timeout in seconds\n        \"KEY_PREFIX\": \"myapp\",       # Prefix for all keys\n        \"VERSION\": 1,                # Key version number\n        \"OPTIONS\": {\n            # See options below\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#backend-classes","title":"Backend Classes","text":"Backend Description <code>ValkeyCache</code> Standard Valkey connection <code>RedisCache</code> Standard Redis connection <code>ValkeySentinelCache</code> Valkey Sentinel high availability <code>RedisSentinelCache</code> Redis Sentinel high availability <code>RedisClusterCache</code> Redis/Valkey Cluster sharding <p>All backends are in <code>django_cachex.cache</code>.</p> <p>Valkey and Redis Compatibility</p> <p>Valkey and Redis are fully compatible - you can use either backend with either server. We recommend Valkey as it remains fully open source.</p> <p>ValkeyClusterCache</p> <p><code>ValkeyClusterCache</code> is currently unavailable due to an upstream bug in valkey-py. Use <code>RedisClusterCache</code> with your Valkey cluster instead.</p> <p>ValkeySentinelCache</p> <p><code>ValkeySentinelCache</code> is currently unavailable due to an upstream bug in valkey-py. Use <code>RedisSentinelCache</code> with your Valkey server instead (protocol compatible).</p>"},{"location":"user-guide/configuration/#location","title":"LOCATION","text":"<p>Server URL(s). Supports multiple formats:</p> <pre><code># Single server (Valkey)\n\"LOCATION\": \"valkey://127.0.0.1:6379/1\"\n\n# Single server (Redis)\n\"LOCATION\": \"redis://127.0.0.1:6379/1\"\n\n# With authentication\n\"LOCATION\": \"valkey://user:password@127.0.0.1:6379/1\"\n\n# SSL/TLS\n\"LOCATION\": \"valkeys://127.0.0.1:6379/1\"  # or rediss://\n\n# Unix socket\n\"LOCATION\": \"unix:///path/to/socket?db=1\"\n\n# Multiple servers (read replicas)\n\"LOCATION\": [\n    \"valkey://127.0.0.1:6379/1\",  # Primary (writes)\n    \"valkey://127.0.0.1:6380/1\",  # Replica (reads)\n]\n\n# Or comma/semicolon separated\n\"LOCATION\": \"valkey://127.0.0.1:6379/1,valkey://127.0.0.1:6380/1\"\n</code></pre>"},{"location":"user-guide/configuration/#options-reference","title":"OPTIONS Reference","text":""},{"location":"user-guide/configuration/#serialization","title":"Serialization","text":"<pre><code>\"OPTIONS\": {\n    # Single serializer (string path, class, or instance)\n    \"serializer\": \"django_cachex.serializers.pickle.PickleSerializer\",\n\n    # Or with fallback for migration\n    \"serializer\": [\n        \"django_cachex.serializers.msgpack.MessagePackSerializer\",  # Write\n        \"django_cachex.serializers.pickle.PickleSerializer\",    # Fallback read\n    ],\n}\n</code></pre> <p>Available serializers:</p> Serializer Description <code>django_cachex.serializers.pickle.PickleSerializer</code> Python pickle (default) <code>django_cachex.serializers.json.JSONSerializer</code> JSON <code>django_cachex.serializers.msgpack.MessagePackSerializer</code> MessagePack (requires msgpack)"},{"location":"user-guide/configuration/#compression","title":"Compression","text":"<pre><code>\"OPTIONS\": {\n    # Single compressor\n    \"compressor\": \"django_cachex.compressors.zstd.ZStdCompressor\",\n\n    # Or with fallback for migration\n    \"compressor\": [\n        \"django_cachex.compressors.zstd.ZStdCompressor\",  # Write\n        \"django_cachex.compressors.zlib.ZlibCompressor\",  # Fallback read\n    ],\n}\n</code></pre> <p>Available compressors:</p> Compressor Description <code>django_cachex.compressors.zlib.ZlibCompressor</code> zlib compression <code>django_cachex.compressors.gzip.GzipCompressor</code> gzip compression <code>django_cachex.compressors.lz4.Lz4Compressor</code> LZ4 (requires lz4) <code>django_cachex.compressors.lzma.LzmaCompressor</code> LZMA <code>django_cachex.compressors.zstd.ZStdCompressor</code> Zstandard (requires zstd) <p>Compression is only applied to values larger than <code>min_length</code> bytes (default: 256).</p>"},{"location":"user-guide/configuration/#connection-pool","title":"Connection Pool","text":"<pre><code>\"OPTIONS\": {\n    # Custom pool class (use valkey.ConnectionPool for Valkey)\n    \"pool_class\": \"valkey.ConnectionPool\",\n\n    # Pool size and options (passed to pool constructor)\n    \"max_connections\": 100,\n    \"retry_on_timeout\": True,\n\n    # Socket timeouts\n    \"socket_connect_timeout\": 5,\n    \"socket_timeout\": 5,\n}\n</code></pre>"},{"location":"user-guide/configuration/#parser","title":"Parser","text":"<pre><code>\"OPTIONS\": {\n    # For Valkey with libvalkey\n    \"parser_class\": \"valkey.connection.LibvalkeyParser\",\n    # For Redis with hiredis\n    # \"parser_class\": \"redis.connection.HiredisParser\",\n}\n</code></pre>"},{"location":"user-guide/configuration/#exception-handling","title":"Exception Handling","text":"<pre><code>\"OPTIONS\": {\n    # Ignore connection errors (return default/None instead)\n    \"ignore_exceptions\": True,\n\n    # Log ignored exceptions\n    \"log_ignored_exceptions\": True,\n}\n</code></pre>"},{"location":"user-guide/configuration/#connection-lifecycle","title":"Connection Lifecycle","text":"<pre><code>\"OPTIONS\": {\n    # Close connections after each request\n    \"close_connection\": True,\n}\n</code></pre>"},{"location":"user-guide/configuration/#authentication","title":"Authentication","text":""},{"location":"user-guide/configuration/#password-in-url","title":"Password in URL","text":"<pre><code>\"LOCATION\": \"valkey://user:password@127.0.0.1:6379/1\"\n</code></pre>"},{"location":"user-guide/configuration/#password-with-special-characters","title":"Password with Special Characters","text":"<p>For passwords with special characters, pass separately:</p> <pre><code>\"LOCATION\": \"valkey://127.0.0.1:6379/1\",\n\"OPTIONS\": {\n    \"password\": \"my$pecial!password\",\n}\n</code></pre>"},{"location":"user-guide/configuration/#valkeyredis-acls","title":"Valkey/Redis ACLs","text":"<pre><code>\"LOCATION\": \"valkey://username@127.0.0.1:6379/1\",\n\"OPTIONS\": {\n    \"password\": \"password\",\n}\n</code></pre>"},{"location":"user-guide/configuration/#ssltls","title":"SSL/TLS","text":""},{"location":"user-guide/configuration/#basic-ssl","title":"Basic SSL","text":"<pre><code>\"LOCATION\": \"valkeys://127.0.0.1:6379/1\"  # or rediss://\n</code></pre>"},{"location":"user-guide/configuration/#self-signed-certificates","title":"Self-Signed Certificates","text":"<pre><code>\"LOCATION\": \"valkeys://127.0.0.1:6379/1\",\n\"OPTIONS\": {\n    \"ssl_cert_reqs\": None,  # Disable verification\n}\n</code></pre>"},{"location":"user-guide/configuration/#custom-certificates","title":"Custom Certificates","text":"<pre><code>\"LOCATION\": \"valkeys://127.0.0.1:6379/1\",\n\"OPTIONS\": {\n    \"ssl_ca_certs\": \"/path/to/ca.crt\",\n    \"ssl_certfile\": \"/path/to/client.crt\",\n    \"ssl_keyfile\": \"/path/to/client.key\",\n}\n</code></pre>"},{"location":"user-guide/configuration/#sentinel-configuration","title":"Sentinel Configuration","text":"<pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.client.RedisSentinelCache\",\n        \"LOCATION\": \"redis://mymaster/0\",  # Master name\n        \"OPTIONS\": {\n            \"sentinels\": [\n                (\"sentinel1.example.com\", 26379),\n                (\"sentinel2.example.com\", 26379),\n                (\"sentinel3.example.com\", 26379),\n            ],\n            \"sentinel_kwargs\": {\n                \"password\": \"sentinel-password\",\n            },\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#cluster-configuration","title":"Cluster Configuration","text":"<pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.client.RedisClusterCache\",\n        \"LOCATION\": \"redis://127.0.0.1:7000\",\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#timeouts","title":"Timeouts","text":""},{"location":"user-guide/configuration/#default-timeout","title":"Default Timeout","text":"<pre><code>\"TIMEOUT\": 300  # 5 minutes, None for no expiry\n</code></pre>"},{"location":"user-guide/configuration/#special-values","title":"Special Values","text":"<pre><code>cache.set(\"key\", \"value\", timeout=0)     # Delete immediately\ncache.set(\"key\", \"value\", timeout=None)  # Never expires\n</code></pre>"},{"location":"user-guide/configuration/#key-configuration","title":"Key Configuration","text":""},{"location":"user-guide/configuration/#key-prefix","title":"Key Prefix","text":"<pre><code>\"KEY_PREFIX\": \"myapp\"\n# Keys become: myapp:1:keyname\n</code></pre>"},{"location":"user-guide/configuration/#key-version","title":"Key Version","text":"<pre><code>\"VERSION\": 1\n# Keys become: prefix:1:keyname\n</code></pre>"},{"location":"user-guide/configuration/#custom-key-function","title":"Custom Key Function","text":"<pre><code>def my_key_func(key, key_prefix, version):\n    return f\"{key_prefix}:v{version}:{key}\"\n\nCACHES = {\n    \"default\": {\n        ...\n        \"KEY_FUNCTION\": \"myapp.cache.my_key_func\",\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#complete-example","title":"Complete Example","text":"<pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",\n        \"LOCATION\": \"valkey://127.0.0.1:6379/1\",\n        \"TIMEOUT\": 300,\n        \"KEY_PREFIX\": \"myapp\",\n        \"VERSION\": 1,\n        \"OPTIONS\": {\n            # Serialization\n            \"serializer\": \"django_cachex.serializers.pickle.PickleSerializer\",\n\n            # Compression\n            \"compressor\": \"django_cachex.compressors.zstd.ZStdCompressor\",\n\n            # Connection pool\n            \"max_connections\": 50,\n            \"socket_connect_timeout\": 5,\n            \"socket_timeout\": 5,\n\n            # Exception handling\n            \"ignore_exceptions\": False,\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/sentinel/","title":"Valkey/Redis Sentinel","text":"<p>For basic sentinel setup, see Configuration.</p>"},{"location":"user-guide/sentinel/#configuration-options","title":"Configuration Options","text":"Option Description <code>sentinels</code> List of (host, port) tuples for Sentinel nodes (required) <code>sentinel_kwargs</code> Dict of kwargs passed to Sentinel connection (e.g., password) <p>The <code>LOCATION</code> URL format is <code>redis://service_name/db</code> where <code>service_name</code> is the master name configured in Sentinel.</p>"},{"location":"user-guide/sentinel/#how-it-works","title":"How It Works","text":"<p>The Sentinel backend automatically:</p> <ol> <li>Connects to Sentinel nodes to discover the current primary</li> <li>Creates separate connection pools for primary (writes) and replica (reads)</li> <li>Handles failover automatically when the primary changes</li> </ol>"},{"location":"user-guide/serializers/","title":"Serializers","text":"<p>django-cachex supports pluggable serializers for data before sending to Valkey/Redis.</p>"},{"location":"user-guide/serializers/#configuration","title":"Configuration","text":"<pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_cachex.cache.ValkeyCache\",\n        \"LOCATION\": \"valkey://127.0.0.1:6379/1\",\n        \"OPTIONS\": {\n            \"serializer\": \"django_cachex.serializers.json.JSONSerializer\",\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/serializers/#available-serializers","title":"Available Serializers","text":"Serializer Description <code>django_cachex.serializers.pickle.PickleSerializer</code> Python pickle (default) - supports all Python types <code>django_cachex.serializers.json.JSONSerializer</code> JSON - interoperable but limited to JSON types <code>django_cachex.serializers.msgpack.MessagePackSerializer</code> MessagePack - fast and compact binary format <p>MessagePack requires the optional dependency:</p> <pre><code>uv add django-cachex[msgpack]\n</code></pre>"},{"location":"user-guide/serializers/#fallback-for-migration","title":"Fallback for Migration","text":"<p>Specify a list of serializers to safely migrate between formats. The first is used for writing, all are tried for reading:</p> <pre><code>\"OPTIONS\": {\n    \"serializer\": [\n        \"django_cachex.serializers.json.JSONSerializer\",     # Write with new format\n        \"django_cachex.serializers.pickle.PickleSerializer\", # Read old format\n    ],\n}\n</code></pre>"},{"location":"user-guide/serializers/#custom-serializers","title":"Custom Serializers","text":"<p>Implement <code>dumps</code> and <code>loads</code> methods, raising <code>SerializerError</code> on failure:</p> <pre><code>from django_cachex.serializers.base import BaseSerializer\nfrom django_cachex.exceptions import SerializerError\n\nclass MySerializer(BaseSerializer):\n    def dumps(self, value):\n        return my_encode(value)\n\n    def loads(self, value):\n        try:\n            return my_decode(value)\n        except MyDecodeError as e:\n            raise SerializerError from e\n</code></pre>"}]}